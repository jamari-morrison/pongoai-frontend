/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import * as Types from './Types';
import { GetWindow, Visibility } from './Types';
interface HTMLElementWithBoundingRectCacheId extends HTMLElement {
    __tabsterCacheId?: string;
}
export interface WindowWithUID extends Window {
    __tabsterCrossOriginWindowUID?: string;
}
export interface HTMLElementWithUID extends HTMLElement {
    __tabsterElementUID?: string;
}
export interface TabsterDOMRect {
    bottom: number;
    left: number;
    right: number;
    top: number;
}
export interface InstanceContext {
    elementByUId: {
        [uid: string]: WeakHTMLElement<HTMLElementWithUID>;
    };
    basics: Types.InternalBasics;
    WeakRef?: WeakRefConstructor;
    containerBoundingRectCache: {
        [id: string]: {
            rect: TabsterDOMRect;
            element: HTMLElementWithBoundingRectCacheId;
        };
    };
    lastContainerBoundingRectCacheId: number;
    containerBoundingRectCacheTimer?: number;
    fakeWeakRefs: TabsterWeakRef<any>[];
    fakeWeakRefsTimer?: number;
    fakeWeakRefsStarted: boolean;
}
export declare function getInstanceContext(getWindow: GetWindow): InstanceContext;
export declare function disposeInstanceContext(win: Window): void;
export declare function createWeakMap<K extends object, V>(win: Window): WeakMap<K, V>;
interface TabsterWeakRef<T> {
    deref(): T | undefined;
}
export declare class WeakHTMLElement<T extends HTMLElement = HTMLElement, D = undefined> implements Types.WeakHTMLElement<D> {
    private _ref;
    private _data;
    constructor(getWindow: GetWindow, element: T, data?: D);
    get(): T | undefined;
    getData(): D | undefined;
}
export declare function cleanupFakeWeakRefs(getWindow: GetWindow, forceRemove?: boolean): void;
export declare function startFakeWeakRefsCleanup(getWindow: GetWindow): void;
export declare function stopFakeWeakRefsCleanupAndClearStorage(getWindow: GetWindow): void;
export declare function createElementTreeWalker(doc: Document, root: Node, acceptNode: (node: Node) => number): TreeWalker | undefined;
export declare function getBoundingRect(getWindow: GetWindow, element: HTMLElementWithBoundingRectCacheId): TabsterDOMRect;
export declare function isElementVerticallyVisibleInContainer(getWindow: GetWindow, element: HTMLElement): boolean;
export declare function isElementVisibleInContainer(getWindow: GetWindow, element: HTMLElement, gap?: number): Visibility;
export declare function scrollIntoView(getWindow: GetWindow, element: HTMLElement, alignToTop: boolean): void;
export declare function getScrollableContainer(element: HTMLElement): HTMLElement | null;
export declare function makeFocusIgnored(element: HTMLElement): void;
export declare function shouldIgnoreFocus(element: HTMLElement): boolean;
export declare function getUId(wnd: Window & {
    msCrypto?: Crypto;
}): string;
export declare function getElementUId(getWindow: GetWindow, element: HTMLElementWithUID): string;
export declare function getElementByUId(context: InstanceContext, uid: string): WeakHTMLElement<HTMLElementWithUID, undefined> | undefined;
export declare function getWindowUId(win: WindowWithUID): string;
export declare function clearElementCache(getWindow: GetWindow, parent?: HTMLElement): void;
export declare function documentContains(doc: HTMLDocument | null | undefined, element: HTMLElement): boolean;
export declare function matchesSelector(element: HTMLElement, selector: string): boolean;
export declare function getPromise(getWindow: GetWindow): PromiseConstructor;
export declare function getWeakRef<T>(context: InstanceContext): WeakRefConstructor | undefined;
export declare function setBasics(win: Window, basics: Types.InternalBasics): void;
export declare abstract class TabsterPart<P, D = undefined> implements Types.TabsterPart<P> {
    protected _tabster: Types.TabsterInternal;
    protected _element: WeakHTMLElement<HTMLElement, D>;
    protected _props: P;
    readonly id: string;
    constructor(tabster: Types.TabsterInternal, element: HTMLElement, props: P);
    getElement(): HTMLElement | undefined;
    getProps(): P;
    setProps(props: P): void;
}
export interface DummyInputProps {
    /** The input is created to be used only once and autoremoved when focused. */
    isPhantom?: boolean;
    /** Whether the input is before or after the content it is guarding  */
    isFirst: boolean;
}
export declare type DummyInputFocusCallback = (dummyInput: DummyInput) => void;
/**
 * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them
 */
export declare class DummyInput {
    private _isPhantom;
    input: HTMLDivElement | undefined;
    /** Flag that indicates focus is leaving the boundary of the dummy input */
    shouldMoveOut?: boolean;
    isFirst: DummyInputProps['isFirst'];
    /** Called when the input is focused */
    onFocusIn?: DummyInputFocusCallback;
    /** Called when the input is blurred */
    onFocusOut?: DummyInputFocusCallback;
    constructor(getWindow: Types.GetWindow, props: DummyInputProps);
    dispose(): void;
    private _focusIn;
    private _focusOut;
}
/**
 * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)
 */
export declare class DummyInputManager {
    private _unobserve;
    protected _element: WeakHTMLElement;
    protected firstDummy: DummyInput;
    protected lastDummy: DummyInput;
    constructor(tabster: Types.TabsterCore, element: WeakHTMLElement);
    dispose(): void;
    /**
     * Prepares to move focus out of the given element by focusing
     * one of the dummy inputs and setting the `shouldMoveOut` flag
     * @param backwards focus moving to an element behind the given element
     */
    moveOutWithDefaultAction: (backwards: boolean) => void;
    /**
     * Adds dummy inputs as the first and last child of the given element
     * Called each time the children under the element is mutated
     */
    private _addDummyInputs;
    /**
     * Creates a mutation observer to ensure that on DOM changes, the dummy inputs
     * stay as the first and last child elements
     */
    private _observeMutations;
}
export declare function getLastChild(container: HTMLElement): HTMLElement | null;
export declare function triggerEvent<D>(target: HTMLElement | EventTarget, name: string, details: D): boolean;
export {};
