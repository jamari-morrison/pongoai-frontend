'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var keyborg = require('keyborg');

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var TabsterAttributeName = 'data-tabster';
var TabsterDummyInputAttributeName = 'data-tabster-dummy';
var DeloserEventName = 'tabster:deloser';
var ModalizerEventName = 'tabster:modalizer';
var MoverEventName = 'tabster:mover';
var ObservedElementAccesibilities = {
  Any: 0,
  Accessible: 1,
  Focusable: 2
};
var RestoreFocusOrders = {
  History: 0,
  DeloserDefault: 1,
  RootDefault: 2,
  DeloserFirst: 3,
  RootFirst: 4
};
var Visibilities = {
  Invisible: 0,
  PartiallyVisible: 1,
  Visible: 2
};
var MoverDirections = {
  Both: 0,
  Vertical: 1,
  Horizontal: 2,
  Grid: 3
};
var GroupperTabbabilities = {
  Unlimited: 0,
  Limited: 1,
  LimitedTrapFocus: 2
};

var Types = {
    __proto__: null,
    TabsterAttributeName: TabsterAttributeName,
    TabsterDummyInputAttributeName: TabsterDummyInputAttributeName,
    DeloserEventName: DeloserEventName,
    ModalizerEventName: ModalizerEventName,
    MoverEventName: MoverEventName,
    ObservedElementAccesibilities: ObservedElementAccesibilities,
    RestoreFocusOrders: RestoreFocusOrders,
    Visibilities: Visibilities,
    MoverDirections: MoverDirections,
    GroupperTabbabilities: GroupperTabbabilities
};

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function getTabsterOnElement(tabster, element) {
  var _a;

  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;
}
function updateTabsterByAttribute(tabster, element, dispose) {
  var _a, _b;

  var newAttrValue = dispose || tabster._noop ? undefined : element.getAttribute(TabsterAttributeName);
  var tabsteri = tabster;
  var entry = tabsteri.storageEntry(element);
  var newAttr;

  if (newAttrValue) {
    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {
      try {
        var newValue = JSON.parse(newAttrValue);

        if (typeof newValue !== 'object') {
          throw new Error("Value is not a JSON object, got '" + newAttrValue + "'.");
        }

        newAttr = {
          string: newAttrValue,
          object: newValue
        };
      } catch (e) {
        {
          console.error("data-tabster attribute error: " + e, element);
        }
      }
    } else {
      return;
    }
  } else if (!entry) {
    return;
  }

  if (!entry) {
    entry = tabster.storageEntry(element, true);
  }

  if (!entry.tabster) {
    entry.tabster = {};
  }

  var tabsterOnElement = entry.tabster || {};
  var oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};
  var newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};

  for (var _i = 0, _c = Object.keys(oldTabsterProps); _i < _c.length; _i++) {
    var key = _c[_i];

    if (!newTabsterProps[key]) {
      if (key === 'root') {
        var root = tabsterOnElement[key];

        if (root) {
          tabsteri.updateRoot(root, true);
        }
      } else if (key === 'modalizer') {
        var modalizer = tabsterOnElement.modalizer;

        if (tabsteri.updateModalizer && modalizer) {
          tabsteri.updateModalizer(modalizer, true);
        }
      }

      switch (key) {
        case 'deloser':
        case 'root':
        case 'groupper':
        case 'modalizer':
        case 'mover':
          var part = tabsterOnElement[key];

          if (part) {
            part.dispose();
            delete tabsterOnElement[key];
          }

          break;

        case 'observed':
          delete tabsterOnElement[key];

          if (tabsteri.updateObserved) {
            tabsteri.updateObserved(element);
          }

          break;

        case 'focusable':
        case 'outline':
        case 'uncontrolled':
          delete tabsterOnElement[key];
          break;
      }
    }
  }

  for (var _d = 0, _e = Object.keys(newTabsterProps); _d < _e.length; _d++) {
    var key = _e[_d];

    switch (key) {
      case 'deloser':
        if (tabsterOnElement.deloser) {
          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);
        } else {
          if (tabsteri.createDeloser) {
            tabsterOnElement.deloser = tabsteri.createDeloser(tabsteri, element, newTabsterProps.deloser);
          } else {
            console.error('Deloser API used before initializing, please call `getDeloser()`');
          }
        }

        break;

      case 'root':
        if (tabsterOnElement.root) {
          tabsterOnElement.root.setProps(newTabsterProps.root);
        } else {
          tabsterOnElement.root = tabsteri.createRoot(tabsteri, element, newTabsterProps.root);
        }

        tabsteri.updateRoot(tabsterOnElement.root);
        break;

      case 'modalizer':
        if (tabsterOnElement.modalizer) {
          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);
        } else {
          if (tabsteri.createModalizer) {
            tabsterOnElement.modalizer = tabsteri.createModalizer(tabsteri, element, newTabsterProps.modalizer);
          } else {
            console.error('Modalizer API used before initializing, please call `getModalizer()`');
          }
        }

        break;

      case 'focusable':
        tabsterOnElement.focusable = newTabsterProps.focusable;
        break;

      case 'groupper':
        if (tabsterOnElement.groupper) {
          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);
        } else {
          if (tabsteri.createGroupper) {
            tabsterOnElement.groupper = tabsteri.createGroupper(tabsteri, element, newTabsterProps.groupper);
          } else {
            console.error('Groupper API used before initializing, please call `getGroupper()`');
          }
        }

        break;

      case 'mover':
        if (tabsterOnElement.mover) {
          tabsterOnElement.mover.setProps(newTabsterProps.mover);
        } else {
          if (tabsteri.createMover) {
            tabsterOnElement.mover = tabsteri.createMover(tabsteri, element, newTabsterProps.mover);
          } else {
            console.error('Mover API used before initializing, please call `getMover()`');
          }
        }

        break;

      case 'observed':
        if (tabsteri.updateObserved) {
          tabsterOnElement.observed = newTabsterProps.observed;
          tabsteri.updateObserved(element);
        } else {
          console.error('ObservedElement API used before initializing, please call `getObservedElement()`');
        }

        break;

      case 'uncontrolled':
        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;
        break;

      case 'outline':
        if (tabsteri.outline) {
          tabsterOnElement.outline = newTabsterProps.outline;
        } else {
          console.error('Outline API used before initializing, please call `getOutline()`');
        }

        break;

      default:
        console.error("Unknown key '" + key + "' in data-tabster attribute value.");
    }
  }

  if (newAttr) {
    entry.attr = newAttr;
  } else {
    if (Object.keys(tabsterOnElement).length === 0) {
      delete entry.tabster;
      delete entry.attr;
    }

    tabsteri.storageEntry(element, false);
  }
}
function augmentAttribute(tabster, element, name, value // Restore original value when undefined.
) {
  var entry = tabster.storageEntry(element, true);

  if (!entry.aug) {
    if (value === undefined) {
      return;
    }

    entry.aug = {};
  }

  if (value === undefined) {
    if (name in entry.aug) {
      var origVal = entry.aug[name];
      delete entry.aug[name];

      if (origVal === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, origVal);
      }
    }
  } else {
    if (!(name in entry.aug)) {
      entry.aug[name] = element.getAttribute(name);
    }

    if (value === null) {
      element.removeAttribute(name);
    } else {
      element.setAttribute(name, value);
    }
  }

  if (value === undefined && Object.keys(entry.aug).length === 0) {
    delete entry.aug;
    tabster.storageEntry(element, false);
  }
}

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Subscribable = /*#__PURE__*/function () {
  function Subscribable() {
    this._callbacks = [];
  }

  Subscribable.prototype.dispose = function () {
    this._callbacks = [];
    delete this._val;
  };

  Subscribable.prototype.subscribe = function (callback) {
    var index = this._callbacks.indexOf(callback);

    if (index < 0) {
      this._callbacks.push(callback);
    }
  };

  Subscribable.prototype.unsubscribe = function (callback) {
    var index = this._callbacks.indexOf(callback);

    if (index >= 0) {
      this._callbacks.splice(index, 1);
    }
  };

  Subscribable.prototype.setVal = function (val, details) {
    if (this._val === val) {
      return;
    }

    this._val = val;

    this._callCallbacks(val, details);
  };

  Subscribable.prototype.getVal = function () {
    return this._val;
  };

  Subscribable.prototype.trigger = function (val, details) {
    this._callCallbacks(val, details);
  };

  Subscribable.prototype._callCallbacks = function (val, details) {
    this._callbacks.forEach(function (callback) {
      return callback(val, details);
    });
  };

  return Subscribable;
}();

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

var KeyboardNavigationState = /*#__PURE__*/function (_super) {
  tslib.__extends(KeyboardNavigationState, _super);

  function KeyboardNavigationState(getWindow) {
    var _this = _super.call(this) || this;

    _this._onChange = function (isNavigatingWithKeyboard) {
      _this.setVal(isNavigatingWithKeyboard, undefined);
    };

    _this._keyborg = keyborg.createKeyborg(getWindow());

    _this._keyborg.subscribe(_this._onChange);

    return _this;
  }

  KeyboardNavigationState.prototype.dispose = function () {
    _super.prototype.dispose.call(this);

    if (this._keyborg) {
      this._keyborg.unsubscribe(this._onChange);

      keyborg.disposeKeyborg(this._keyborg);
      delete this._keyborg;
    }
  };

  KeyboardNavigationState.dispose = function (instance) {
    instance.dispose();
  };

  KeyboardNavigationState.setVal = function (instance, val) {
    var _a;

    (_a = instance._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(val);
  };

  KeyboardNavigationState.prototype.isNavigatingWithKeyboard = function () {
    var _a;

    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());
  };

  return KeyboardNavigationState;
}(Subscribable);

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

var _isBrokenIE11;

var _DOMRect = typeof DOMRect !== 'undefined' ? DOMRect : /*#__PURE__*/function () {
  function class_1(x, y, width, height) {
    this.left = x || 0;
    this.top = y || 0;
    this.right = (x || 0) + (width || 0);
    this.bottom = (y || 0) + (height || 0);
  }

  return class_1;
}();

var _uidCounter = 0;

try {
  // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`
  // property as the docs define). Also `entityReferenceExpansion` argument is not
  // optional. And it throws exception when the above arguments aren't there.
  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);
  _isBrokenIE11 = false;
} catch (e) {
  _isBrokenIE11 = true;
}

function getInstanceContext(getWindow) {
  var win = getWindow();
  var ctx = win.__tabsterInstanceContext;

  if (!ctx) {
    ctx = {
      elementByUId: {},
      basics: {
        Promise: win.Promise || undefined,
        WeakRef: win.WeakRef || undefined
      },
      containerBoundingRectCache: {},
      lastContainerBoundingRectCacheId: 0,
      fakeWeakRefs: [],
      fakeWeakRefsStarted: false
    };
    win.__tabsterInstanceContext = ctx;
  }

  return ctx;
}
function disposeInstanceContext(win) {
  var ctx = win.__tabsterInstanceContext;

  if (ctx) {
    ctx.elementByUId = {};
    delete ctx.WeakRef;
    ctx.containerBoundingRectCache = {};

    if (ctx.containerBoundingRectCacheTimer) {
      win.clearTimeout(ctx.containerBoundingRectCacheTimer);
    }

    if (ctx.fakeWeakRefsTimer) {
      win.clearTimeout(ctx.fakeWeakRefsTimer);
    }

    ctx.fakeWeakRefs = [];
    delete win.__tabsterInstanceContext;
  }
}
function createWeakMap(win) {
  var ctx = win.__tabsterInstanceContext;
  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();
}

var FakeWeakRef = /*#__PURE__*/function () {
  function FakeWeakRef(target) {
    this._target = target;
  }

  FakeWeakRef.prototype.deref = function () {
    return this._target;
  };

  FakeWeakRef.cleanup = function (fwr, forceRemove) {
    if (!fwr._target) {
      return true;
    }

    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {
      delete fwr._target;
      return true;
    }

    return false;
  };

  return FakeWeakRef;
}();

var WeakHTMLElement = /*#__PURE__*/function () {
  function WeakHTMLElement(getWindow, element, data) {
    var context = getInstanceContext(getWindow);
    var ref;

    if (context.WeakRef) {
      ref = new context.WeakRef(element);
    } else {
      ref = new FakeWeakRef(element);
      context.fakeWeakRefs.push(ref);
    }

    this._ref = ref;
    this._data = data;
  }

  WeakHTMLElement.prototype.get = function () {
    var ref = this._ref;
    var element;

    if (ref) {
      element = ref.deref();

      if (!element) {
        delete this._ref;
      }
    }

    return element;
  };

  WeakHTMLElement.prototype.getData = function () {
    return this._data;
  };

  return WeakHTMLElement;
}();
function cleanupFakeWeakRefs(getWindow, forceRemove) {
  var context = getInstanceContext(getWindow);
  context.fakeWeakRefs = context.fakeWeakRefs.filter(function (e) {
    return !FakeWeakRef.cleanup(e, forceRemove);
  });
}
function startFakeWeakRefsCleanup(getWindow) {
  var context = getInstanceContext(getWindow);

  if (!context.fakeWeakRefsStarted) {
    context.fakeWeakRefsStarted = true;
    context.WeakRef = getWeakRef(context);
  }

  if (!context.fakeWeakRefsTimer) {
    context.fakeWeakRefsTimer = getWindow().setTimeout(function () {
      context.fakeWeakRefsTimer = undefined;
      cleanupFakeWeakRefs(getWindow);
      startFakeWeakRefsCleanup(getWindow);
    }, 2 * 60 * 1000); // 2 minutes.
  }
}
function stopFakeWeakRefsCleanupAndClearStorage(getWindow) {
  var context = getInstanceContext(getWindow);
  context.fakeWeakRefsStarted = false;

  if (context.fakeWeakRefsTimer) {
    getWindow().clearTimeout(context.fakeWeakRefsTimer);
    context.fakeWeakRefsTimer = undefined;
    context.fakeWeakRefs = [];
  }
}
function createElementTreeWalker(doc, root, acceptNode) {
  // IE11 will throw an exception when the TreeWalker root is not an Element.
  if (root.nodeType !== Node.ELEMENT_NODE) {
    return undefined;
  } // TypeScript isn't aware of IE11 behaving badly.


  var filter = _isBrokenIE11 ? acceptNode : {
    acceptNode: acceptNode
  }; // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.

  return doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter, false
  /* Last argument is not optional for IE11! */
  );
}
function getBoundingRect(getWindow, element) {
  var cacheId = element.__tabsterCacheId;
  var context = getInstanceContext(getWindow);
  var cached = cacheId ? context.containerBoundingRectCache[cacheId] : undefined;

  if (cached) {
    return cached.rect;
  }

  var scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;

  if (!scrollingElement) {
    return new _DOMRect();
  } // A bounding rect of the top-level element contains the whole page regardless of the
  // scrollbar. So, we improvise a little and limiting the final result...


  var left = 0;
  var top = 0;
  var right = scrollingElement.clientWidth;
  var bottom = scrollingElement.clientHeight;

  if (element !== scrollingElement) {
    var r = element.getBoundingClientRect();
    left = Math.max(left, r.left);
    top = Math.max(top, r.top);
    right = Math.min(right, r.right);
    bottom = Math.min(bottom, r.bottom);
  }

  var rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);

  if (!cacheId) {
    cacheId = 'r-' + ++context.lastContainerBoundingRectCacheId;
    element.__tabsterCacheId = cacheId;
  }

  context.containerBoundingRectCache[cacheId] = {
    rect: rect,
    element: element
  };

  if (!context.containerBoundingRectCacheTimer) {
    context.containerBoundingRectCacheTimer = window.setTimeout(function () {
      context.containerBoundingRectCacheTimer = undefined;

      for (var _i = 0, _a = Object.keys(context.containerBoundingRectCache); _i < _a.length; _i++) {
        var cId = _a[_i];
        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;
      }

      context.containerBoundingRectCache = {};
    }, 50);
  }

  return rect;
}
function isElementVerticallyVisibleInContainer(getWindow, element) {
  var container = getScrollableContainer(element);

  if (container) {
    var containerRect = getBoundingRect(getWindow, container);
    var elementRect = element.getBoundingClientRect();
    return elementRect.top >= containerRect.top && elementRect.bottom <= containerRect.bottom;
  }

  return false;
}
function isElementVisibleInContainer(getWindow, element, gap) {
  if (gap === void 0) {
    gap = 0;
  }

  var container = getScrollableContainer(element);

  if (container) {
    var containerRect = getBoundingRect(getWindow, container);
    var elementRect = element.getBoundingClientRect();

    if (elementRect.left > containerRect.right || elementRect.top > containerRect.bottom || elementRect.bottom < containerRect.top || elementRect.right < containerRect.left) {
      return Visibilities.Invisible;
    }

    if (elementRect.top + gap >= containerRect.top && elementRect.top <= containerRect.bottom && elementRect.bottom >= containerRect.top && elementRect.bottom - gap <= containerRect.bottom && elementRect.left + gap >= containerRect.left && elementRect.left <= containerRect.right && elementRect.right >= containerRect.left && elementRect.right - gap <= containerRect.right) {
      return Visibilities.Visible;
    }

    return Visibilities.PartiallyVisible;
  }

  return Visibilities.Invisible;
}
function scrollIntoView(getWindow, element, alignToTop) {
  // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,
  // it scrolls all of them, not just the deepest one. So, trying to work it around.
  var container = getScrollableContainer(element);

  if (container) {
    var containerRect = getBoundingRect(getWindow, container);
    var elementRect = element.getBoundingClientRect();

    if (alignToTop) {
      container.scrollTop += elementRect.top - containerRect.top;
    } else {
      container.scrollTop += elementRect.bottom - containerRect.bottom;
    }
  }
}
function getScrollableContainer(element) {
  var doc = element.ownerDocument;

  if (doc) {
    for (var el = element.parentElement; el; el = el.parentElement) {
      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
        return el;
      }
    }

    return doc.documentElement;
  }

  return null;
}
function makeFocusIgnored(element) {
  element.__shouldIgnoreFocus = true;
}
function shouldIgnoreFocus(element) {
  return !!element.__shouldIgnoreFocus;
}
function getUId(wnd) {
  var rnd = new Uint32Array(4);

  if (wnd.crypto && wnd.crypto.getRandomValues) {
    wnd.crypto.getRandomValues(rnd);
  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {
    wnd.msCrypto.getRandomValues(rnd);
  } else {
    for (var i = 0; i < rnd.length; i++) {
      rnd[i] = 0xffffffff * Math.random();
    }
  }

  var srnd = [];

  for (var i = 0; i < rnd.length; i++) {
    srnd.push(rnd[i].toString(36));
  }

  srnd.push('|');
  srnd.push((++_uidCounter).toString(36));
  srnd.push('|');
  srnd.push(Date.now().toString(36));
  return srnd.join('');
}
function getElementUId(getWindow, element) {
  var context = getInstanceContext(getWindow);
  var uid = element.__tabsterElementUID;

  if (!uid) {
    uid = element.__tabsterElementUID = getUId(getWindow());
  }

  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {
    context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);
  }

  return uid;
}
function getWindowUId(win) {
  var uid = win.__tabsterCrossOriginWindowUID;

  if (!uid) {
    uid = win.__tabsterCrossOriginWindowUID = getUId(win);
  }

  return uid;
}
function clearElementCache(getWindow, parent) {
  var context = getInstanceContext(getWindow);

  for (var _i = 0, _a = Object.keys(context.elementByUId); _i < _a.length; _i++) {
    var key = _a[_i];
    var wel = context.elementByUId[key];
    var el = wel && wel.get();

    if (el && parent) {
      if (!parent.contains(el)) {
        continue;
      }
    }

    delete context.elementByUId[key];
  }
} // IE11 doesn't have document.contains()...

function documentContains(doc, element) {
  var _a;

  return !!((_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.contains(element));
}
function matchesSelector(element, selector) {
  var matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;
  return matches && matches.call(element, selector);
}
function getPromise(getWindow) {
  var context = getInstanceContext(getWindow);

  if (context.basics.Promise) {
    return context.basics.Promise;
  }

  throw new Error('No Promise defined.');
}
function getWeakRef(context) {
  return context.basics.WeakRef;
}
function setBasics(win, basics) {
  var context = getInstanceContext(function () {
    return win;
  });
  var key;
  key = 'Promise';

  if (key in basics) {
    context.basics[key] = basics[key];
  }

  key = 'WeakRef';

  if (key in basics) {
    context.basics[key] = basics[key];
  }

  key = 'WeakMap';

  if (key in basics) {
    context.basics[key] = basics[key];
  }
}
var _lastTabsterPartId = 0;

var TabsterPart = /*#__PURE__*/function () {
  function TabsterPart(tabster, element, props) {
    var getWindow = tabster.getWindow;
    this._tabster = tabster;
    this._element = new WeakHTMLElement(getWindow, element);
    this._props = tslib.__assign({}, props);
    this.id = 'i' + ++_lastTabsterPartId;
  }

  TabsterPart.prototype.getElement = function () {
    return this._element.get();
  };

  TabsterPart.prototype.getProps = function () {
    return this._props;
  };

  TabsterPart.prototype.setProps = function (props) {
    this._props = tslib.__assign({}, props);
  };

  return TabsterPart;
}();
/**
 * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them
 */

var DummyInput = /*#__PURE__*/function () {
  function DummyInput(getWindow, props) {
    var _this = this;

    var _a;

    this._focusIn = function (e) {
      if (_this.onFocusIn && _this.input) {
        _this.onFocusIn(_this);
      }
    };

    this._focusOut = function (e) {
      _this.shouldMoveOut = false;

      if (_this.onFocusOut && _this.input) {
        _this.onFocusOut(_this);
      }

      if (_this._isPhantom) {
        _this.dispose();
      }
    };

    var input = getWindow().document.createElement('div');
    input.tabIndex = 0;
    input.setAttribute('role', 'none');
    input.setAttribute(TabsterDummyInputAttributeName, '');
    input.setAttribute('aria-hidden', 'true');
    var style = input.style;
    style.position = 'fixed';
    style.width = style.height = '1px';
    style.left = style.top = '-100500px';
    style.opacity = '0';
    style.zIndex = '-1';

    {
      style.setProperty('--tabster-dummy-input', 'yes');
    }

    makeFocusIgnored(input);
    this.input = input;
    this.isFirst = props.isFirst;
    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;
    input.addEventListener('focusin', this._focusIn);
    input.addEventListener('focusout', this._focusOut);
  }

  DummyInput.prototype.dispose = function () {
    var _a;

    var input = this.input;

    if (!input) {
      return;
    }

    delete this.onFocusIn;
    delete this.onFocusOut;
    delete this.input;
    input.removeEventListener('focusin', this._focusIn);
    input.removeEventListener('focusout', this._focusOut);
    (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);
  };

  return DummyInput;
}();
/**
 * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)
 */

var DummyInputManager = /*#__PURE__*/function () {
  function DummyInputManager(tabster, element) {
    var _this = this;
    /**
     * Prepares to move focus out of the given element by focusing
     * one of the dummy inputs and setting the `shouldMoveOut` flag
     * @param backwards focus moving to an element behind the given element
     */


    this.moveOutWithDefaultAction = function (backwards) {
      var first = _this.firstDummy;
      var last = _this.lastDummy;

      if ((first === null || first === void 0 ? void 0 : first.input) && (last === null || last === void 0 ? void 0 : last.input)) {
        if (backwards) {
          first.shouldMoveOut = true;
          first.input.focus();
        } else {
          last.shouldMoveOut = true;
          last.input.focus();
        }
      }
    };

    var win = tabster.getWindow;
    this.firstDummy = new DummyInput(win, {
      isFirst: true
    });
    this.lastDummy = new DummyInput(win, {
      isFirst: false
    });
    this._element = element;

    this._addDummyInputs(); // older versions of testing frameworks like JSDOM don't support MutationObserver
    // https://github.com/jsdom/jsdom/issues/639
    // use this way of getting NODE_ENV because tsdx does not support a test environment
    // https://github.com/jaredpalmer/tsdx/issues/167


    if (typeof process === 'undefined' || process.env['NODE_ENV'] !== 'test') {
      this._observeMutations(win);
    }
  }

  DummyInputManager.prototype.dispose = function () {
    var _a;

    this.firstDummy.dispose();
    this.lastDummy.dispose();
    (_a = this._unobserve) === null || _a === void 0 ? void 0 : _a.call(this);
  };
  /**
   * Adds dummy inputs as the first and last child of the given element
   * Called each time the children under the element is mutated
   */


  DummyInputManager.prototype._addDummyInputs = function () {
    var _a, _b;

    var element = this._element.get();

    var dif = (_a = this.firstDummy) === null || _a === void 0 ? void 0 : _a.input;
    var dil = (_b = this.lastDummy) === null || _b === void 0 ? void 0 : _b.input;

    if (!element || !dif || !dil) {
      return;
    }

    if (element.lastElementChild !== dil) {
      element.appendChild(dil);
    }

    var firstElementChild = element.firstElementChild;

    if (firstElementChild && firstElementChild !== dif) {
      element.insertBefore(dif, firstElementChild);
    }
  };
  /**
   * Creates a mutation observer to ensure that on DOM changes, the dummy inputs
   * stay as the first and last child elements
   */


  DummyInputManager.prototype._observeMutations = function (win) {
    var _this = this;

    if (this._unobserve) {
      return;
    }

    var observer = new MutationObserver(function () {
      _this._addDummyInputs();
    });

    var element = this._element.get();

    if (element) {
      observer.observe(element, {
        childList: true
      });

      this._unobserve = function () {
        observer.disconnect();
      };
    }
  };

  return DummyInputManager;
}();
function getLastChild(container) {
  var lastChild = null;

  for (var i = container.lastElementChild; i; i = i.lastElementChild) {
    lastChild = i;
  }

  return lastChild;
}
function triggerEvent(target, name, details) {
  var event = document.createEvent('HTMLEvents');
  event.initEvent(name, true, true);
  event.details = details;
  target.dispatchEvent(event);
  return !event.defaultPrevented;
}

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

function _setInformativeStyle(weakElement, remove, id) {
  {
    var element = weakElement.get();

    if (element) {
      if (remove) {
        element.style.removeProperty('--tabster-root');
      } else {
        element.style.setProperty('--tabster-root', id + ',');
      }
    }
  }
}

var RootDummyManager = /*#__PURE__*/function (_super) {
  tslib.__extends(RootDummyManager, _super);

  function RootDummyManager(tabster, element, setFocused) {
    var _this = _super.call(this, tabster, element) || this;

    _this.setTabbable = function (tabbable) {
      var tabIndex = tabbable ? 0 : -1;

      if (_this.firstDummy.input) {
        _this.firstDummy.input.tabIndex = tabIndex;
      }

      if (_this.lastDummy.input) {
        _this.lastDummy.input.tabIndex = tabIndex;
      }
    };

    _this._onDummyInputFocus = function (dummyInput) {
      var _a;

      if (dummyInput.shouldMoveOut) {
        // When we've reached the last focusable element, we want to let the browser
        // to move the focus outside of the page. In order to do that we're synchronously
        // calling focus() of the dummy input from the Tab key handler and allowing
        // the default action to move the focus out.
        _this._setFocused(false, true);
      } else {
        // The only way a dummy input gets focused is during the keyboard navigation.
        KeyboardNavigationState.setVal(_this._tabster.keyboardNavigation, true);

        var element = _this._element.get();

        if (element) {
          _this._setFocused(true, true);

          var hasFocused = dummyInput.isFirst ? _this._tabster.focusedElement.focusFirst({
            container: element
          }) : _this._tabster.focusedElement.focusLast({
            container: element
          });

          if (hasFocused) {
            return;
          }
        }

        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();
      }
    };

    _this._tabster = tabster;
    _this._setFocused = setFocused;
    _this.firstDummy.onFocusIn = _this._onDummyInputFocus;
    _this.lastDummy.onFocusIn = _this._onDummyInputFocus;
    return _this;
  }

  return RootDummyManager;
}(DummyInputManager);

var Root = /*#__PURE__*/function (_super) {
  tslib.__extends(Root, _super);

  function Root(tabster, element, props) {
    var _this = _super.call(this, tabster, element, props) || this;

    _this._isFocused = false;

    _this._setFocused = function (hasFocused, fromAdjacent) {
      if (_this._setFocusedTimer) {
        _this._tabster.getWindow().clearTimeout(_this._setFocusedTimer);

        delete _this._setFocusedTimer;
      }

      if (_this._isFocused === hasFocused) {
        return;
      }

      var element = _this._element.get();

      if (element) {
        if (hasFocused) {
          _this._isFocused = true;
          triggerEvent(_this._tabster.root.eventTarget, 'focus', {
            element: element,
            fromAdjacent: fromAdjacent
          });
        } else {
          _this._setFocusedTimer = _this._tabster.getWindow().setTimeout(function () {
            delete _this._setFocusedTimer;
            _this._isFocused = false;
            triggerEvent(_this._tabster.root.eventTarget, 'blur', {
              element: element,
              fromAdjacent: fromAdjacent
            });
          }, 0);
        }
      }
    };

    _this._onFocus = function (e) {
      var _a, _b;

      if (e) {
        var ctx = RootAPI.getTabsterContext(_this._tabster, e);

        if (ctx) {
          _this._setFocused(ctx.root.getElement() === _this._element.get());
        }

        if (!ctx || ctx.uncontrolled) {
          (_a = _this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);
          return;
        }
      } else {
        _this._setFocused(false);
      }

      (_b = _this._dummyManager) === null || _b === void 0 ? void 0 : _b.setTabbable(true);
    };

    var win = tabster.getWindow;
    _this.uid = getElementUId(win, element);

    if (tabster.controlTab) {
      _this._dummyManager = new RootDummyManager(tabster, _this._element, _this._setFocused);
    }

    tabster.focusedElement.subscribe(_this._onFocus);

    _this._add();

    return _this;
  }

  Root.prototype.dispose = function () {
    var _a;

    if (this._setFocusedTimer) {
      this._tabster.getWindow().clearTimeout(this._setFocusedTimer);

      delete this._setFocusedTimer;
    }

    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();

    this._remove();
  };

  Root.prototype.moveOutWithDefaultAction = function (backwards) {
    var _a;

    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards);
  };

  Root.prototype._add = function () {
    {
      _setInformativeStyle(this._element, false, this.uid);
    }
  };

  Root.prototype._remove = function () {
    {
      _setInformativeStyle(this._element, true);
    }
  };

  return Root;
}(TabsterPart);

var RootAPI = /*#__PURE__*/function () {
  function RootAPI(tabster, autoRoot) {
    var _this = this;

    this.rootById = {};

    this._init = function () {
      _this._initTimer = undefined;
    };

    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._initTimer = this._win().setTimeout(this._init, 0);
    this._autoRoot = autoRoot;
    this.eventTarget = new EventTarget();
  }

  RootAPI.prototype.dispose = function () {
    var win = this._win();

    if (this._autoRootInstance) {
      this._autoRootInstance.dispose();

      delete this._autoRootInstance;
      delete this._autoRoot;
    }

    if (this._initTimer) {
      win.clearTimeout(this._initTimer);
      this._initTimer = undefined;
    }

    this.rootById = {};
  };

  RootAPI.dispose = function (instance) {
    instance.dispose();
  };

  RootAPI.getRootByUId = function (getWindow, id) {
    var tabster = getWindow().__tabsterInstance;

    return tabster && tabster.root.rootById[id];
  };
  /**
   * Fetches the tabster context for an element walking up its ancestors
   *
   * @param tabster Tabster instance
   * @param element The element the tabster context should represent
   * @param options Additional options
   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations
   */


  RootAPI.getTabsterContext = function (tabster, element, options) {
    var _a;

    if (options === void 0) {
      options = {};
    }

    if (!element.ownerDocument) {
      return undefined;
    }

    var checkRtl = options.checkRtl;
    var root;
    var modalizer;
    var groupper;
    var mover;
    var isGroupperFirst;
    var isRtl;
    var uncontrolled;
    var curElement = element;

    while (curElement && (!root || checkRtl)) {
      var tabsterOnElement = getTabsterOnElement(tabster, curElement);

      if (checkRtl && isRtl === undefined) {
        var dir = curElement.dir;

        if (dir) {
          isRtl = dir.toLowerCase() === 'rtl';
        }
      }

      if (!tabsterOnElement) {
        curElement = curElement.parentElement;
        continue;
      }

      if (tabsterOnElement.uncontrolled) {
        uncontrolled = curElement;
      }

      var curGroupper = tabsterOnElement.groupper;
      var curMover = tabsterOnElement.mover;

      if (!groupper && curGroupper) {
        groupper = curGroupper;
      }

      if (!mover && curMover) {
        mover = curMover;
        isGroupperFirst = !!groupper;
      }

      if (!modalizer && tabsterOnElement.modalizer) {
        modalizer = tabsterOnElement.modalizer;
      }

      if (tabsterOnElement.root) {
        root = tabsterOnElement.root;
      }

      curElement = curElement.parentElement;
    } // No root element could be found, try to get an auto root


    if (!root) {
      var rootAPI = tabster.root;
      var autoRoot = rootAPI._autoRoot;

      if (autoRoot && !rootAPI._autoRootInstance) {
        var body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;

        if (body) {
          rootAPI._autoRootInstance = new Root(rootAPI._tabster, body, autoRoot);
        }
      }

      root = rootAPI._autoRootInstance;
    }

    return root ? {
      root: root,
      modalizer: modalizer,
      groupper: groupper,
      mover: mover,
      isGroupperFirst: isGroupperFirst,
      isRtl: checkRtl ? !!isRtl : undefined,
      uncontrolled: uncontrolled
    } : undefined;
  };

  RootAPI.onRoot = function (instance, root, removed) {
    if (removed) {
      delete instance.rootById[root.uid];
    } else {
      instance.rootById[root.uid] = root;
    }
  };

  RootAPI.createRoot = function (tabster, element, props) {

    return new Root(tabster, element, props);
  };

  return RootAPI;
}();

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _containerHistoryLength = 10;

var DeloserItemBase = /*#__PURE__*/function () {
  function DeloserItemBase() {}

  return DeloserItemBase;
}();

var DeloserItem = /*#__PURE__*/function (_super) {
  tslib.__extends(DeloserItem, _super);

  function DeloserItem(tabster, deloser) {
    var _this = _super.call(this) || this;

    _this.uid = deloser.uid;
    _this._tabster = tabster;
    _this._deloser = deloser;
    return _this;
  }

  DeloserItem.prototype.belongsTo = function (deloser) {
    return deloser === this._deloser;
  };

  DeloserItem.prototype.unshift = function (element) {
    this._deloser.unshift(element);
  };

  DeloserItem.prototype.focusAvailable = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var available;
      return tslib.__generator(this, function (_a) {
        available = this._deloser.findAvailable();
        return [2
        /*return*/
        , available ? this._tabster.focusedElement.focus(available) : false];
      });
    });
  };

  DeloserItem.prototype.resetFocus = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var getWindow;
      return tslib.__generator(this, function (_a) {
        getWindow = this._tabster.getWindow;
        return [2
        /*return*/
        , getPromise(getWindow).resolve(this._deloser.resetFocus())];
      });
    });
  };

  return DeloserItem;
}(DeloserItemBase);

var DeloserHistoryByRootBase = /*#__PURE__*/function () {
  function DeloserHistoryByRootBase(tabster, rootUId) {
    this._history = [];
    this._tabster = tabster;
    this.rootUId = rootUId;
  }

  DeloserHistoryByRootBase.prototype.getLength = function () {
    return this._history.length;
  };

  DeloserHistoryByRootBase.prototype.removeDeloser = function (deloser) {
    this._history = this._history.filter(function (c) {
      return !c.belongsTo(deloser);
    });
  };

  DeloserHistoryByRootBase.prototype.hasDeloser = function (deloser) {
    return this._history.some(function (d) {
      return d.belongsTo(deloser);
    });
  };

  return DeloserHistoryByRootBase;
}();

var DeloserHistoryByRoot = /*#__PURE__*/function (_super) {
  tslib.__extends(DeloserHistoryByRoot, _super);

  function DeloserHistoryByRoot() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DeloserHistoryByRoot.prototype.unshiftToDeloser = function (deloser, element) {
    var item;

    for (var i = 0; i < this._history.length; i++) {
      if (this._history[i].belongsTo(deloser)) {
        item = this._history[i];

        this._history.splice(i, 1);

        break;
      }
    }

    if (!item) {
      item = new DeloserItem(this._tabster, deloser);
    }

    item.unshift(element);

    this._history.unshift(item);

    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);
  };

  DeloserHistoryByRoot.prototype.focusAvailable = function (from) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var skip, _i, _a, i, _b;

      return tslib.__generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            skip = !!from;
            _i = 0, _a = this._history;
            _c.label = 1;

          case 1:
            if (!(_i < _a.length)) return [3
            /*break*/
            , 5];
            i = _a[_i];

            if (from && i.belongsTo(from)) {
              skip = false;
            }

            _b = !skip;
            if (!_b) return [3
            /*break*/
            , 3];
            return [4
            /*yield*/
            , i.focusAvailable()];

          case 2:
            _b = _c.sent();
            _c.label = 3;

          case 3:
            if (_b) {
              return [2
              /*return*/
              , true];
            }

            _c.label = 4;

          case 4:
            _i++;
            return [3
            /*break*/
            , 1];

          case 5:
            return [2
            /*return*/
            , false];
        }
      });
    });
  };

  DeloserHistoryByRoot.prototype.resetFocus = function (from) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var skip, resetQueue, _i, _a, i, _b, _c, id;

      return tslib.__generator(this, function (_d) {
        switch (_d.label) {
          case 0:
            skip = !!from;
            resetQueue = {};

            for (_i = 0, _a = this._history; _i < _a.length; _i++) {
              i = _a[_i];

              if (from && i.belongsTo(from)) {
                skip = false;
              }

              if (!skip && !resetQueue[i.uid]) {
                resetQueue[i.uid] = i;
              }
            }

            _b = 0, _c = Object.keys(resetQueue);
            _d.label = 1;

          case 1:
            if (!(_b < _c.length)) return [3
            /*break*/
            , 4];
            id = _c[_b];
            return [4
            /*yield*/
            , resetQueue[id].resetFocus()];

          case 2:
            if (_d.sent()) {
              return [2
              /*return*/
              , true];
            }

            _d.label = 3;

          case 3:
            _b++;
            return [3
            /*break*/
            , 1];

          case 4:
            return [2
            /*return*/
            , false];
        }
      });
    });
  };

  return DeloserHistoryByRoot;
}(DeloserHistoryByRootBase);

var DeloserHistory = /*#__PURE__*/function () {
  function DeloserHistory(tabster) {
    this._history = [];
    this._tabster = tabster;
  }

  DeloserHistory.prototype.dispose = function () {
    this._history = [];
  };

  DeloserHistory.prototype.process = function (element) {
    var _this = this;

    var _a;

    var ctx = RootAPI.getTabsterContext(this._tabster, element);
    var rootUId = ctx && ctx.root.uid;
    var deloser = DeloserAPI.getDeloser(this._tabster, element);

    if (!rootUId || !deloser) {
      return undefined;
    }

    var historyByRoot = this.make(rootUId, function () {
      return new DeloserHistoryByRoot(_this._tabster, rootUId);
    });

    if (!ctx || !ctx.modalizer || ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {
      historyByRoot.unshiftToDeloser(deloser, element);
    }

    return deloser;
  };

  DeloserHistory.prototype.make = function (rootUId, createInstance) {
    var historyByRoot;

    for (var i = 0; i < this._history.length; i++) {
      var hbr = this._history[i];

      if (hbr.rootUId === rootUId) {
        historyByRoot = hbr;

        this._history.splice(i, 1);

        break;
      }
    }

    if (!historyByRoot) {
      historyByRoot = createInstance();
    }

    this._history.unshift(historyByRoot);

    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);

    return historyByRoot;
  };

  DeloserHistory.prototype.removeDeloser = function (deloser) {
    this._history.forEach(function (i) {
      i.removeDeloser(deloser);
    });

    this._history = this._history.filter(function (i) {
      return i.getLength() > 0;
    });
  };

  DeloserHistory.prototype.focusAvailable = function (from) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var skip, _i, _a, h, _b;

      return tslib.__generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            skip = !!from;
            _i = 0, _a = this._history;
            _c.label = 1;

          case 1:
            if (!(_i < _a.length)) return [3
            /*break*/
            , 5];
            h = _a[_i];

            if (from && h.hasDeloser(from)) {
              skip = false;
            }

            _b = !skip;
            if (!_b) return [3
            /*break*/
            , 3];
            return [4
            /*yield*/
            , h.focusAvailable(from)];

          case 2:
            _b = _c.sent();
            _c.label = 3;

          case 3:
            if (_b) {
              return [2
              /*return*/
              , true];
            }

            _c.label = 4;

          case 4:
            _i++;
            return [3
            /*break*/
            , 1];

          case 5:
            return [2
            /*return*/
            , false];
        }
      });
    });
  };

  DeloserHistory.prototype.resetFocus = function (from) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var skip, _i, _a, h, _b;

      return tslib.__generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            skip = !!from;
            _i = 0, _a = this._history;
            _c.label = 1;

          case 1:
            if (!(_i < _a.length)) return [3
            /*break*/
            , 5];
            h = _a[_i];

            if (from && h.hasDeloser(from)) {
              skip = false;
            }

            _b = !skip;
            if (!_b) return [3
            /*break*/
            , 3];
            return [4
            /*yield*/
            , h.resetFocus(from)];

          case 2:
            _b = _c.sent();
            _c.label = 3;

          case 3:
            if (_b) {
              return [2
              /*return*/
              , true];
            }

            _c.label = 4;

          case 4:
            _i++;
            return [3
            /*break*/
            , 1];

          case 5:
            return [2
            /*return*/
            , false];
        }
      });
    });
  };

  return DeloserHistory;
}();

function _setInformativeStyle$1(weakElement, remove, isActive, snapshotIndex) {
  {
    var element = weakElement.get();

    if (element) {
      if (remove) {
        element.style.removeProperty('--tabster-deloser');
      } else {
        element.style.setProperty('--tabster-deloser', (isActive ? 'active' : 'inactive') + ',' + ('snapshot-' + snapshotIndex));
      }
    }
  }
}

function buildElementSelector(element, withClass, withIndex) {
  var selector = [];
  var escapeRegExp = /(:|\.|\[|\]|,|=|@)/g;
  var escapeReplaceValue = '\\$1';

  if (element.id) {
    selector.push('#' + element.id.replace(escapeRegExp, escapeReplaceValue));
  }

  if (withClass !== false && element.className) {
    element.className.split(' ').forEach(function (cls) {
      cls = cls.trim();

      if (cls) {
        selector.push('.' + cls.replace(escapeRegExp, escapeReplaceValue));
      }
    });
  }

  var index = 0;
  var el;

  if (withIndex !== false && selector.length === 0) {
    el = element;

    while (el) {
      index++;
      el = el.previousElementSibling;
    }

    selector.unshift(':nth-child(' + index + ')');
  }

  selector.unshift(element.tagName.toLowerCase());
  return selector.join('');
}

function buildSelector(element) {
  if (!documentContains(element.ownerDocument, element)) {
    return undefined;
  }

  var selector = [buildElementSelector(element)];
  var el = element.parentElement;

  while (el) {
    var isBody = el.tagName === 'BODY';
    selector.unshift(buildElementSelector(el, false, !isBody));

    if (isBody) {
      break;
    }

    el = el.parentElement;
  }

  return selector.join(' ');
}

var Deloser = /*#__PURE__*/function (_super) {
  tslib.__extends(Deloser, _super);

  function Deloser(tabster, element, onDispose, props) {
    var _this = _super.call(this, tabster, element, props) || this;

    _this._isActive = false;
    _this._history = [[]];
    _this._snapshotIndex = 0;

    _this.isActive = function () {
      return _this._isActive;
    };

    _this.setSnapshot = function (index) {
      _this._snapshotIndex = index;

      if (_this._history.length > index + 1) {
        _this._history.splice(index + 1, _this._history.length - index - 1);
      }

      if (!_this._history[index]) {
        _this._history[index] = [];
      }

      {
        _setInformativeStyle$1(_this._element, false, _this._isActive, _this._snapshotIndex);
      }
    };

    _this.focusFirst = function () {
      var e = _this._element.get();

      return !!e && _this._tabster.focusedElement.focusFirst({
        container: e
      });
    };

    _this.focusDefault = function () {
      var e = _this._element.get();

      return !!e && _this._tabster.focusedElement.focusDefault(e);
    };

    _this.resetFocus = function () {
      var e = _this._element.get();

      return !!e && _this._tabster.focusedElement.resetFocus(e);
    };

    _this.clearHistory = function (preserveExisting) {
      var element = _this._element.get();

      if (!element) {
        _this._history[_this._snapshotIndex] = [];
        return;
      }

      _this._history[_this._snapshotIndex] = _this._history[_this._snapshotIndex].filter(function (we) {
        var e = we.get();
        return e && preserveExisting ? element.contains(e) : false;
      });
    };

    _this.uid = getElementUId(tabster.getWindow, element);
    _this._onDispose = onDispose;

    {
      _setInformativeStyle$1(_this._element, false, _this._isActive, _this._snapshotIndex);
    }

    return _this;
  }

  Deloser.prototype.dispose = function () {
    this._remove();

    this._onDispose(this);

    this._isActive = false;
    this._snapshotIndex = 0;
    this._props = {};
    this._history = [];
  };

  Deloser.prototype.setActive = function (active) {
    this._isActive = active;

    {
      _setInformativeStyle$1(this._element, false, this._isActive, this._snapshotIndex);
    }
  };

  Deloser.prototype.getActions = function () {
    return {
      focusDefault: this.focusDefault,
      focusFirst: this.focusFirst,
      resetFocus: this.resetFocus,
      clearHistory: this.clearHistory,
      setSnapshot: this.setSnapshot,
      isActive: this.isActive
    };
  };

  Deloser.prototype.unshift = function (element) {
    var cur = this._history[this._snapshotIndex];
    cur = this._history[this._snapshotIndex] = cur.filter(function (we) {
      var e = we.get();
      return e && e !== element;
    });
    cur.unshift(new WeakHTMLElement(this._tabster.getWindow, element, buildSelector(element)));

    while (cur.length > _containerHistoryLength) {
      cur.pop();
    }
  };

  Deloser.prototype.findAvailable = function () {
    var element = this._element.get();

    if (!element || !this._tabster.focusable.isVisible(element)) {
      return null;
    }

    var restoreFocusOrder = this._props.restoreFocusOrder;
    var available = null;
    var ctx = RootAPI.getTabsterContext(this._tabster, element);

    if (!ctx) {
      return null;
    }

    var root = ctx.root;
    var rootElement = root.getElement();

    if (!rootElement) {
      return null;
    }

    if (restoreFocusOrder === undefined) {
      restoreFocusOrder = root.getProps().restoreFocusOrder;
    }

    if (restoreFocusOrder === RestoreFocusOrders.RootDefault) {
      available = this._tabster.focusable.findDefault({
        container: rootElement
      });
    }

    if (!available && restoreFocusOrder === RestoreFocusOrders.RootFirst) {
      available = this._findFirst(rootElement);
    }

    if (available) {
      return available;
    }

    var availableInHistory = this._findInHistory();

    var availableDefault = this._tabster.focusable.findDefault({
      container: element
    });

    var availableFirst = this._findFirst(element);

    if (availableInHistory && restoreFocusOrder === RestoreFocusOrders.History) {
      return availableInHistory;
    }

    if (availableDefault && restoreFocusOrder === RestoreFocusOrders.DeloserDefault) {
      return availableDefault;
    }

    if (availableFirst && restoreFocusOrder === RestoreFocusOrders.DeloserFirst) {
      return availableFirst;
    }

    return availableDefault || availableInHistory || availableFirst || null;
  };

  Deloser.prototype.customFocusLostHandler = function (element) {
    return triggerEvent(element, DeloserEventName, this.getActions());
  };

  Deloser.prototype._findInHistory = function () {
    var cur = this._history[this._snapshotIndex].slice(0);

    this.clearHistory(true);

    for (var i = 0; i < cur.length; i++) {
      var we = cur[i];
      var e = we.get();

      var element = this._element.get();

      if (e && element && element.contains(e)) {
        if (this._tabster.focusable.isFocusable(e)) {
          return e;
        }
      } else if (!this._props.noSelectorCheck) {
        // Element is not in the DOM, try to locate the node by it's
        // selector. This might return not exactly the right node,
        // but it would be easily fixable by having more detailed selectors.
        var selector = we.getData();

        if (selector && element) {
          var els = void 0;

          try {
            els = element.ownerDocument.querySelectorAll(selector);
          } catch (e) {
            {
              // This should never happen, unless there is some bug in buildElementSelector().
              console.error("Failed to querySelectorAll('" + selector + "')");
            }

            continue;
          }

          for (var i_1 = 0; i_1 < els.length; i_1++) {
            var el = els[i_1];

            if (el && this._tabster.focusable.isFocusable(el)) {
              return el;
            }
          }
        }
      }
    }

    return null;
  };

  Deloser.prototype._findFirst = function (element) {
    if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {
      var first = this._tabster.focusable.findFirst({
        container: element
      });

      if (first) {
        return first;
      }
    }

    return null;
  };

  Deloser.prototype._remove = function () {
    {
      _setInformativeStyle$1(this._element, true);
    }
  };

  return Deloser;
}(TabsterPart);

var DeloserAPI = /*#__PURE__*/function () {
  function DeloserAPI(tabster, props) {
    var _this = this;
    /**
     * Tracks if focus is inside a deloser
     */


    this._inDeloser = false;
    this._isRestoringFocus = false;
    this._isPaused = false;

    this._init = function () {
      _this._initTimer = undefined;

      _this._tabster.focusedElement.subscribe(_this._onFocus);
    };

    this._onFocus = function (e) {
      if (_this._restoreFocusTimer) {
        _this._win().clearTimeout(_this._restoreFocusTimer);

        _this._restoreFocusTimer = undefined;
      }

      if (!e) {
        _this._scheduleRestoreFocus();

        return;
      }

      var deloser = _this._history.process(e);

      if (deloser) {
        _this._activate(deloser);
      } else {
        _this._deactivate();
      }
    };

    this._onDeloserDispose = function (deloser) {
      _this._history.removeDeloser(deloser);

      if (deloser.isActive()) {
        _this._scheduleRestoreFocus();
      }
    };

    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._history = new DeloserHistory(tabster);
    this._initTimer = this._win().setTimeout(this._init, 0);
    var autoDeloser = props === null || props === void 0 ? void 0 : props.autoDeloser;

    if (autoDeloser) {
      this._autoDeloser = autoDeloser;
    }
  }

  DeloserAPI.prototype.dispose = function () {
    var win = this._win();

    if (this._initTimer) {
      win.clearTimeout(this._initTimer);
      this._initTimer = undefined;
    }

    if (this._restoreFocusTimer) {
      win.clearTimeout(this._restoreFocusTimer);
      this._restoreFocusTimer = undefined;
    }

    if (this._autoDeloserInstance) {
      this._autoDeloserInstance.dispose();

      delete this._autoDeloserInstance;
      delete this._autoDeloser;
    }

    this._tabster.focusedElement.unsubscribe(this._onFocus);

    this._history.dispose();

    delete this._curDeloser;
  };

  DeloserAPI.dispose = function (instance) {
    instance.dispose();
  };

  DeloserAPI.prototype.getActions = function (element) {
    for (var e = element; e; e = e.parentElement) {
      var tabsterOnElement = getTabsterOnElement(this._tabster, e);

      if (tabsterOnElement && tabsterOnElement.deloser) {
        return tabsterOnElement.deloser.getActions();
      }
    }

    return undefined;
  };

  DeloserAPI.prototype.pause = function () {
    this._isPaused = true;

    if (this._restoreFocusTimer) {
      this._win().clearTimeout(this._restoreFocusTimer);

      this._restoreFocusTimer = undefined;
    }
  };

  DeloserAPI.prototype.resume = function (restore) {
    this._isPaused = false;

    if (restore) {
      this._scheduleRestoreFocus();
    }
  };
  /**
   * Activates and sets the current deloser
   */


  DeloserAPI.prototype._activate = function (deloser) {
    var curDeloser = this._curDeloser;

    if (curDeloser !== deloser) {
      this._inDeloser = true;
      curDeloser === null || curDeloser === void 0 ? void 0 : curDeloser.setActive(false);
      deloser.setActive(true);
      this._curDeloser = deloser;
    }
  };
  /**
   * Called when focus should no longer be in a deloser
   */


  DeloserAPI.prototype._deactivate = function () {
    var _a;

    this._inDeloser = false;
    (_a = this._curDeloser) === null || _a === void 0 ? void 0 : _a.setActive(false);
    this._curDeloser = undefined;
  };

  DeloserAPI.prototype._scheduleRestoreFocus = function (force) {
    var _this = this;

    if (this._isPaused || this._isRestoringFocus) {
      return;
    }

    var restoreFocus = function restoreFocus() {
      return tslib.__awaiter(_this, void 0, void 0, function () {
        var lastFocused, curDeloser, el;
        return tslib.__generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              this._restoreFocusTimer = undefined;
              lastFocused = this._tabster.focusedElement.getLastFocusedElement();

              if (!force && (this._isRestoringFocus || !this._inDeloser || !!(lastFocused === null || lastFocused === void 0 ? void 0 : lastFocused.offsetParent))) {
                return [2
                /*return*/
                ];
              }

              curDeloser = this._curDeloser;

              if (curDeloser) {
                if (lastFocused && curDeloser.customFocusLostHandler(lastFocused)) {
                  return [2
                  /*return*/
                  ];
                }

                el = curDeloser.findAvailable();

                if (el && this._tabster.focusedElement.focus(el)) {
                  return [2
                  /*return*/
                  ];
                }
              }

              this._deactivate();

              this._isRestoringFocus = true;
              return [4
              /*yield*/
              , this._history.focusAvailable(null)];

            case 1:
              if (!!_a.sent()) return [3
              /*break*/
              , 3];
              return [4
              /*yield*/
              , this._history.resetFocus(null)];

            case 2:
              _a.sent();

              _a.label = 3;

            case 3:
              this._isRestoringFocus = false;
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    if (force) {
      restoreFocus();
    } else {
      this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);
    }
  };

  DeloserAPI.getDeloser = function (tabster, element) {
    var _a;

    for (var e = element; e; e = e.parentElement) {
      var tabsterOnElement = getTabsterOnElement(tabster, e);

      if (tabsterOnElement && tabsterOnElement.deloser) {
        return tabsterOnElement.deloser;
      }
    }

    var tabsteri = tabster;
    var deloserAPI = tabsteri.deloser && tabsteri.deloser;

    if (deloserAPI) {
      if (deloserAPI._autoDeloserInstance) {
        return deloserAPI._autoDeloserInstance;
      }

      var autoDeloserProps = deloserAPI._autoDeloser;

      if (!deloserAPI._autoDeloserInstance && autoDeloserProps) {
        var body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;

        if (body) {
          deloserAPI._autoDeloserInstance = new Deloser(tabsteri, body, tabsteri.deloser._onDeloserDispose, autoDeloserProps);
        }
      }

      return deloserAPI._autoDeloserInstance;
    }

    return undefined;
  };

  DeloserAPI.getHistory = function (instance) {
    return instance._history;
  };

  DeloserAPI.forceRestoreFocus = function (instance) {
    instance._scheduleRestoreFocus(true);
  };

  DeloserAPI.createDeloser = function (tabster, element, props) {
    var _a;

    var deloser = new Deloser(tabster, element, tabster.deloser._onDeloserDispose, props);

    if (element.contains((_a = tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {
      tabster.deloser._activate(deloser);
    }

    return deloser;
  };

  return DeloserAPI;
}();

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _transactionTimeout = 1500;
var _pingTimeout = 3000;
var _targetIdUp = 'up';
var CrossOriginTransactionTypes = {
  Bootstrap: 1,
  FocusElement: 2,
  State: 3,
  GetElement: 4,
  RestoreFocusInDeloser: 5,
  Ping: 6
};

var CrossOriginDeloserItem = /*#__PURE__*/function (_super) {
  tslib.__extends(CrossOriginDeloserItem, _super);

  function CrossOriginDeloserItem(tabster, deloser, trasactions) {
    var _this = _super.call(this) || this;

    _this._deloser = deloser;
    _this._transactions = trasactions;
    return _this;
  }

  CrossOriginDeloserItem.prototype.belongsTo = function (deloser) {
    return deloser.deloserUId === this._deloser.deloserUId;
  };

  CrossOriginDeloserItem.prototype.focusAvailable = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var data;
      return tslib.__generator(this, function (_a) {
        data = tslib.__assign(tslib.__assign({}, this._deloser), {
          reset: false
        });
        return [2
        /*return*/
        , this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(function (value) {
          return !!value;
        })];
      });
    });
  };

  CrossOriginDeloserItem.prototype.resetFocus = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var data;
      return tslib.__generator(this, function (_a) {
        data = tslib.__assign(tslib.__assign({}, this._deloser), {
          reset: true
        });
        return [2
        /*return*/
        , this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(function (value) {
          return !!value;
        })];
      });
    });
  };

  return CrossOriginDeloserItem;
}(DeloserItemBase);

var CrossOriginDeloserHistoryByRoot = /*#__PURE__*/function (_super) {
  tslib.__extends(CrossOriginDeloserHistoryByRoot, _super);

  function CrossOriginDeloserHistoryByRoot(tabster, rootUId, transactions) {
    var _this = _super.call(this, tabster, rootUId) || this;

    _this._transactions = transactions;
    return _this;
  }

  CrossOriginDeloserHistoryByRoot.prototype.unshift = function (deloser) {
    var item;

    for (var i = 0; i < this._history.length; i++) {
      if (this._history[i].belongsTo(deloser)) {
        item = this._history[i];

        this._history.splice(i, 1);

        break;
      }
    }

    if (!item) {
      item = new CrossOriginDeloserItem(this._tabster, deloser, this._transactions);
    }

    this._history.unshift(item);

    this._history.splice(10, this._history.length - 10);
  };

  CrossOriginDeloserHistoryByRoot.prototype.focusAvailable = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var _i, _a, i;

      return tslib.__generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            _i = 0, _a = this._history;
            _b.label = 1;

          case 1:
            if (!(_i < _a.length)) return [3
            /*break*/
            , 4];
            i = _a[_i];
            return [4
            /*yield*/
            , i.focusAvailable()];

          case 2:
            if (_b.sent()) {
              return [2
              /*return*/
              , true];
            }

            _b.label = 3;

          case 3:
            _i++;
            return [3
            /*break*/
            , 1];

          case 4:
            return [2
            /*return*/
            , false];
        }
      });
    });
  };

  CrossOriginDeloserHistoryByRoot.prototype.resetFocus = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var _i, _a, i;

      return tslib.__generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            _i = 0, _a = this._history;
            _b.label = 1;

          case 1:
            if (!(_i < _a.length)) return [3
            /*break*/
            , 4];
            i = _a[_i];
            return [4
            /*yield*/
            , i.resetFocus()];

          case 2:
            if (_b.sent()) {
              return [2
              /*return*/
              , true];
            }

            _b.label = 3;

          case 3:
            _i++;
            return [3
            /*break*/
            , 1];

          case 4:
            return [2
            /*return*/
            , false];
        }
      });
    });
  };

  return CrossOriginDeloserHistoryByRoot;
}(DeloserHistoryByRootBase);

var CrossOriginTransaction = /*#__PURE__*/function () {
  function CrossOriginTransaction(tabster, getOwner, knownTargets, value, timeout, sentTo, targetId, sendUp) {
    var _a;

    var _this = this;

    this._inProgress = {};
    this._isDone = false;
    this._isSelfResponding = false;
    this._sentCount = 0;
    this.tabster = tabster;
    this.owner = getOwner;
    this.ownerId = getWindowUId(getOwner());
    this.id = getUId(getOwner());
    this.beginData = value;
    this._knownTargets = knownTargets;
    this._sentTo = sentTo || (_a = {}, _a[this.ownerId] = true, _a);
    this.targetId = targetId;
    this.sendUp = sendUp;
    this.timeout = timeout;
    this._promise = new (getPromise(getOwner))(function (resolve, reject) {
      _this._resolve = resolve;
      _this._reject = reject;
    });
  }

  CrossOriginTransaction.prototype.getTargets = function (knownTargets) {
    var _a, _b, _c;

    return this.targetId === _targetIdUp ? this.sendUp ? (_a = {}, _a[_targetIdUp] = {
      send: this.sendUp
    }, _a) : null : this.targetId ? knownTargets[this.targetId] ? (_b = {}, _b[this.targetId] = {
      send: knownTargets[this.targetId].send
    }, _b) : null : Object.keys(knownTargets).length === 0 && this.sendUp ? (_c = {}, _c[_targetIdUp] = {
      send: this.sendUp
    }, _c) : Object.keys(knownTargets).length > 0 ? knownTargets : null;
  };

  CrossOriginTransaction.prototype.begin = function (selfResponse) {
    var _this = this;

    var targets = this.getTargets(this._knownTargets);

    var sentTo = tslib.__assign({}, this._sentTo);

    if (targets) {
      for (var _i = 0, _a = Object.keys(targets); _i < _a.length; _i++) {
        var id = _a[_i];
        sentTo[id] = true;
      }
    }

    var data = {
      transaction: this.id,
      type: this.type,
      isResponse: false,
      timestamp: Date.now(),
      owner: this.ownerId,
      sentto: sentTo,
      timeout: this.timeout,
      beginData: this.beginData
    };

    if (this.targetId) {
      data.target = this.targetId;
    }

    if (selfResponse) {
      this._isSelfResponding = true;
      selfResponse(data).then(function (value) {
        _this._isSelfResponding = false;

        if (value !== undefined) {
          if (!_this.endData) {
            _this.endData = value;
          }
        }

        if (_this.endData || _this._sentCount === 0) {
          _this.end();
        }
      });
    }

    if (targets) {
      for (var _b = 0, _c = Object.keys(targets); _b < _c.length; _b++) {
        var id = _c[_b];

        if (!(id in this._sentTo)) {
          this._send(targets[id].send, id, data);
        }
      }
    }

    if (this._sentCount === 0 && !this._isSelfResponding) {
      this.end();
    }

    return this._promise;
  };

  CrossOriginTransaction.prototype._send = function (send, targetId, data) {
    if (this._inProgress[targetId] === undefined) {
      this._inProgress[targetId] = true;
      this._sentCount++;
      send(data);
    }
  };

  CrossOriginTransaction.prototype.end = function (error) {
    if (this._isDone) {
      return;
    }

    this._isDone = true;

    if (this.endData === undefined && error) {
      if (this._reject) {
        this._reject(error);
      }
    } else if (this._resolve) {
      this._resolve(this.endData);
    }
  };

  CrossOriginTransaction.prototype.onResponse = function (data) {
    var endData = data.endData;

    if (endData !== undefined && !this.endData) {
      this.endData = endData;
    }

    var inProgressId = data.target === _targetIdUp ? _targetIdUp : data.owner;

    if (this._inProgress[inProgressId]) {
      this._inProgress[inProgressId] = false;
      this._sentCount--;

      if (this.endData || this._sentCount === 0 && !this._isSelfResponding) {
        this.end();
      }
    }
  };

  return CrossOriginTransaction;
}();

var BootstrapTransaction = /*#__PURE__*/function (_super) {
  tslib.__extends(BootstrapTransaction, _super);

  function BootstrapTransaction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CrossOriginTransactionTypes.Bootstrap;
    return _this;
  }

  BootstrapTransaction.shouldForward = function () {
    return false;
  };

  BootstrapTransaction.makeResponse = function (tabster) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        return [2
        /*return*/
        , {
          isNavigatingWithKeyboard: tabster.keyboardNavigation.isNavigatingWithKeyboard()
        }];
      });
    });
  };

  return BootstrapTransaction;
}(CrossOriginTransaction);

var FocusElementTransaction = /*#__PURE__*/function (_super) {
  tslib.__extends(FocusElementTransaction, _super);

  function FocusElementTransaction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CrossOriginTransactionTypes.FocusElement;
    return _this;
  }

  FocusElementTransaction.shouldForward = function (tabster, data, getOwner) {
    var el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);
    return !el || !tabster.focusable.isFocusable(el);
  };

  FocusElementTransaction.makeResponse = function (tabster, data, getOwner, ownerId, transactions, forwardResult) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var el, _a;

      return tslib.__generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);
            _a = !!el && tabster.focusedElement.focus(el);
            if (_a) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , forwardResult];

          case 1:
            _a = !!_b.sent();
            _b.label = 2;

          case 2:
            return [2
            /*return*/
            , _a];
        }
      });
    });
  };

  FocusElementTransaction.shouldSelfRespond = function () {
    return true;
  };

  return FocusElementTransaction;
}(CrossOriginTransaction);

var CrossOriginStates = {
  Focused: 1,
  Blurred: 2,
  Observed: 3,
  DeadWindow: 4,
  KeyboardNavigation: 5,
  Outline: 6
};

var StateTransaction = /*#__PURE__*/function (_super) {
  tslib.__extends(StateTransaction, _super);

  function StateTransaction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CrossOriginTransactionTypes.State;
    return _this;
  }

  StateTransaction.shouldSelfRespond = function (tabster, data) {
    return data.state !== CrossOriginStates.DeadWindow && data.state !== CrossOriginStates.KeyboardNavigation;
  };

  StateTransaction.makeResponse = function (tabster, data, getOwner, ownerId, transactions, forwardResult, isSelfResponse) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var timestamp, beginData;
      return tslib.__generator(this, function (_a) {
        timestamp = data.timestamp;
        beginData = data.beginData;

        if (timestamp && beginData) {
          switch (beginData.state) {
            case CrossOriginStates.Focused:
              return [2
              /*return*/
              , StateTransaction._makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse)];

            case CrossOriginStates.Blurred:
              return [2
              /*return*/
              , StateTransaction._makeBlurredResponse(tabster, timestamp, beginData, transactions.ctx)];

            case CrossOriginStates.Observed:
              return [2
              /*return*/
              , StateTransaction._makeObservedResponse(tabster, beginData)];

            case CrossOriginStates.DeadWindow:
              return [2
              /*return*/
              , StateTransaction._makeDeadWindowResponse(tabster, beginData, transactions, forwardResult)];

            case CrossOriginStates.KeyboardNavigation:
              return [2
              /*return*/
              , StateTransaction._makeKeyboardNavigationResponse(tabster, transactions.ctx, beginData.isNavigatingWithKeyboard)];

            case CrossOriginStates.Outline:
              return [2
              /*return*/
              , StateTransaction._makeOutlineResponse(tabster, transactions.ctx, beginData.outline)];
          }
        }

        return [2
        /*return*/
        , true];
      });
    });
  };

  StateTransaction.createElement = function (tabster, beginData) {
    return beginData.uid ? new CrossOriginElement(tabster, beginData.uid, beginData.ownerUId, beginData.id, beginData.rootUId, beginData.observedName, beginData.observedDetails) : null;
  };

  StateTransaction._makeFocusedResponse = function (tabster, timestamp, beginData, transactions, isSelfResponse) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var element, deloserAPI, history_1, deloser_1, historyItem;
      return tslib.__generator(this, function (_a) {
        element = StateTransaction.createElement(tabster, beginData);

        if (beginData && beginData.ownerUId && element) {
          transactions.ctx.focusOwner = beginData.ownerUId;
          transactions.ctx.focusOwnerTimestamp = timestamp;

          if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {
            deloserAPI = tabster.deloser;

            if (deloserAPI) {
              history_1 = DeloserAPI.getHistory(deloserAPI);
              deloser_1 = {
                ownerUId: beginData.ownerUId,
                deloserUId: beginData.deloserUId,
                rootUId: beginData.rootUId
              };
              historyItem = history_1.make(beginData.rootUId, function () {
                return new CrossOriginDeloserHistoryByRoot(tabster, deloser_1.rootUId, transactions);
              });
              historyItem.unshift(deloser_1);
            }
          }

          CrossOriginFocusedElementState.setVal(tabster.crossOrigin.focusedElement, element, {
            isFocusedProgrammatically: beginData.isFocusedProgrammatically
          });
        }

        return [2
        /*return*/
        , true];
      });
    });
  };

  StateTransaction._makeBlurredResponse = function (tabster, timestamp, beginData, context) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        if (beginData && (beginData.ownerUId === context.focusOwner || beginData.force) && (!context.focusOwnerTimestamp || context.focusOwnerTimestamp < timestamp)) {
          CrossOriginFocusedElementState.setVal(tabster.crossOrigin.focusedElement, undefined, {});
        }

        return [2
        /*return*/
        , true];
      });
    });
  };

  StateTransaction._makeObservedResponse = function (tabster, beginData) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var name, element;
      return tslib.__generator(this, function (_a) {
        name = beginData.observedName;
        element = StateTransaction.createElement(tabster, beginData);

        if (name && element) {
          CrossOriginObservedElementState.trigger(tabster.crossOrigin.observedElement, element, {
            name: name,
            details: beginData.observedDetails
          });
        }

        return [2
        /*return*/
        , true];
      });
    });
  };

  StateTransaction._makeDeadWindowResponse = function (tabster, beginData, transactions, forwardResult) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var deadUId;
      return tslib.__generator(this, function (_a) {
        deadUId = beginData && beginData.ownerUId;

        if (deadUId) {
          transactions.removeTarget(deadUId);
        }

        return [2
        /*return*/
        , forwardResult.then(function () {
          if (deadUId === transactions.ctx.focusOwner) {
            var deloserAPI = tabster.deloser;

            if (deloserAPI) {
              DeloserAPI.forceRestoreFocus(deloserAPI);
            }
          }

          return true;
        })];
      });
    });
  };

  StateTransaction._makeKeyboardNavigationResponse = function (tabster, context, isNavigatingWithKeyboard) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        if (isNavigatingWithKeyboard !== undefined && tabster.keyboardNavigation.isNavigatingWithKeyboard() !== isNavigatingWithKeyboard) {
          context.ignoreKeyboardNavigationStateUpdate = true;
          KeyboardNavigationState.setVal(tabster.keyboardNavigation, isNavigatingWithKeyboard);
          context.ignoreKeyboardNavigationStateUpdate = false;
        }

        return [2
        /*return*/
        , true];
      });
    });
  };

  StateTransaction._makeOutlineResponse = function (tabster, context, props) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        if (context.origOutlineSetup) {
          context.origOutlineSetup.call(tabster.outline, props);
        }

        return [2
        /*return*/
        , true];
      });
    });
  };

  return StateTransaction;
}(CrossOriginTransaction);

var GetElementTransaction = /*#__PURE__*/function (_super) {
  tslib.__extends(GetElementTransaction, _super);

  function GetElementTransaction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CrossOriginTransactionTypes.GetElement;
    return _this;
  }

  GetElementTransaction.findElement = function (tabster, getOwner, data) {
    var element;

    if (data && (!data.ownerId || data.ownerId === getWindowUId(getOwner()))) {
      if (data.id) {
        element = getOwner().document.getElementById(data.id);

        if (element && data.rootId) {
          var ctx = RootAPI.getTabsterContext(tabster, element);

          if (!ctx || ctx.root.uid !== data.rootId) {
            return null;
          }
        }
      } else if (data.uid) {
        var ref = getInstanceContext(getOwner).elementByUId[data.uid];
        element = ref && ref.get();
      } else if (data.observedName) {
        element = tabster.observedElement.getElement(data.observedName);
      }
    }

    return element || null;
  };

  GetElementTransaction.getElementData = function (tabster, element, getOwner, context, ownerUId) {
    var deloser = DeloserAPI.getDeloser(tabster, element);
    var ctx = RootAPI.getTabsterContext(tabster, element);
    var tabsterOnElement = getTabsterOnElement(tabster, element);
    var observed = tabsterOnElement && tabsterOnElement.observed;
    return {
      uid: getElementUId(getOwner, element),
      ownerUId: ownerUId,
      id: element.id || undefined,
      rootUId: ctx ? ctx.root.uid : undefined,
      deloserUId: deloser ? getDeloserUID(getOwner, context, deloser) : undefined,
      observedName: observed && observed.name,
      observedDetails: observed && observed.details
    };
  };

  GetElementTransaction.makeResponse = function (tabster, data, getOwner, ownerUId, transactions, forwardResult) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var beginData, element, dataOut, name_1, timeout_1, accessibility_1, e;
      return tslib.__generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            beginData = data.beginData;

            if (beginData === undefined) {
              element = tabster.focusedElement.getFocusedElement();
            } else if (beginData) {
              element = GetElementTransaction.findElement(tabster, getOwner, beginData) || undefined;
            }

            if (!(!element && beginData)) return [3
            /*break*/
            , 2];
            name_1 = beginData.observedName;
            timeout_1 = data.timeout;
            accessibility_1 = beginData.accessibility;
            if (!(name_1 && timeout_1)) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , new (getPromise(getOwner))(function (resolve, reject) {
              var isWaitElementResolved = false;
              var isForwardResolved = false;
              var isResolved = false;
              tabster.observedElement.waitElement(name_1, timeout_1, accessibility_1).result.then(function (value) {
                isWaitElementResolved = true;

                if (!isResolved && (value || isForwardResolved)) {
                  isResolved = true;
                  resolve({
                    element: value
                  });
                }
              });
              forwardResult.then(function (value) {
                isForwardResolved = true;

                if (!isResolved && (value || isWaitElementResolved)) {
                  isResolved = true;
                  resolve({
                    crossOrigin: value
                  });
                }
              });
            })];

          case 1:
            e = _a.sent();

            if (e.element) {
              element = e.element;
            } else if (e.crossOrigin) {
              dataOut = e.crossOrigin;
            }

            _a.label = 2;

          case 2:
            return [2
            /*return*/
            , element ? GetElementTransaction.getElementData(tabster, element, getOwner, transactions.ctx, ownerUId) : dataOut];
        }
      });
    });
  };

  GetElementTransaction.shouldSelfRespond = function () {
    return true;
  };

  return GetElementTransaction;
}(CrossOriginTransaction);

var RestoreFocusInDeloserTransaction = /*#__PURE__*/function (_super) {
  tslib.__extends(RestoreFocusInDeloserTransaction, _super);

  function RestoreFocusInDeloserTransaction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CrossOriginTransactionTypes.RestoreFocusInDeloser;
    return _this;
  }

  RestoreFocusInDeloserTransaction.makeResponse = function (tabster, data, getOwner, ownerId, transactions, forwardResult) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var forwardRet, begin, uid, deloser, deloserAPI, history_2;
      return tslib.__generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4
            /*yield*/
            , forwardResult];

          case 1:
            forwardRet = _a.sent();
            begin = !forwardRet && data.beginData;
            uid = begin && begin.deloserUId;
            deloser = uid && transactions.ctx.deloserByUId[uid];
            deloserAPI = tabster.deloser;

            if (begin && deloser && deloserAPI) {
              history_2 = DeloserAPI.getHistory(deloserAPI);
              return [2
              /*return*/
              , begin.reset ? history_2.resetFocus(deloser) : history_2.focusAvailable(deloser)];
            }

            return [2
            /*return*/
            , !!forwardRet];
        }
      });
    });
  };

  return RestoreFocusInDeloserTransaction;
}(CrossOriginTransaction);

var PingTransaction = /*#__PURE__*/function (_super) {
  tslib.__extends(PingTransaction, _super);

  function PingTransaction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = CrossOriginTransactionTypes.Ping;
    return _this;
  }

  PingTransaction.shouldForward = function () {
    return false;
  };

  PingTransaction.makeResponse = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        return [2
        /*return*/
        , true];
      });
    });
  };

  return PingTransaction;
}(CrossOriginTransaction);

var CrossOriginTransactions = /*#__PURE__*/function () {
  function CrossOriginTransactions(tabster, getOwner, context) {
    var _this = this;

    this._knownTargets = {};
    this._transactions = {};
    this._isDefaultSendUp = false;
    this.isSetUp = false;

    this._onMessage = function (e) {
      if (e.data.owner === _this._ownerUId || !_this._tabster) {
        return;
      }

      var data = e.data;
      var transactionId;

      if (!data || !(transactionId = data.transaction) || !data.type || !data.timestamp || !data.owner || !data.sentto) {
        return;
      }

      var knownTarget = _this._knownTargets[data.owner];

      if (!knownTarget && e.send && data.owner !== _this._ownerUId) {
        knownTarget = _this._knownTargets[data.owner] = {
          send: e.send
        };
      }

      if (knownTarget) {
        knownTarget.last = Date.now();
      }

      if (data.isResponse) {
        var t = _this._transactions[transactionId];

        if (t && t.transaction && t.transaction.type === data.type) {
          t.transaction.onResponse(data);
        }
      } else {
        var Transaction = _this._getTransactionClass(data.type);

        var forwardResult = _this.forwardTransaction(data);

        if (Transaction && e.send) {
          Transaction.makeResponse(_this._tabster, data, _this._owner, _this._ownerUId, _this, forwardResult, false).then(function (r) {
            var response = {
              transaction: data.transaction,
              type: data.type,
              isResponse: true,
              timestamp: Date.now(),
              owner: _this._ownerUId,
              timeout: data.timeout,
              sentto: {},
              target: data.target === _targetIdUp ? _targetIdUp : data.owner,
              endData: r
            };
            e.send(response);
          });
        }
      }
    };

    this._onPageHide = function () {
      _this._dead();
    };

    this._onBrowserMessage = function (e) {
      if (e.source === _this._owner()) {
        return;
      }

      var send = function send(data) {
        if (e.source && e.source.postMessage) {
          e.source.postMessage(JSON.stringify(data), '*');
        }
      };

      try {
        _this._onMessage({
          data: JSON.parse(e.data),
          send: send
        });
      } catch (e) {
        /* Ignore */
      }
    };

    this._tabster = tabster;
    this._owner = getOwner;
    this._ownerUId = getWindowUId(getOwner());
    this.ctx = context;
  }

  CrossOriginTransactions.prototype.setup = function (sendUp) {
    if (this.isSetUp) {
      {
        console.error('CrossOrigin is already set up.');
      }
    } else {
      this.isSetUp = true;
      this.setSendUp(sendUp);

      this._owner().addEventListener('pagehide', this._onPageHide);

      this._ping();
    }

    return this._onMessage;
  };

  CrossOriginTransactions.prototype.setSendUp = function (sendUp) {
    if (!this.isSetUp) {
      throw new Error('CrossOrigin is not set up.');
    }

    this.sendUp = sendUp || undefined;

    var owner = this._owner();

    if (sendUp === undefined) {
      if (!this._isDefaultSendUp) {
        if (owner.document) {
          this._isDefaultSendUp = true;

          if (owner.parent && owner.parent !== owner && owner.parent.postMessage) {
            this.sendUp = function (data) {
              owner.parent.postMessage(JSON.stringify(data), '*');
            };
          }

          owner.addEventListener('message', this._onBrowserMessage);
        }
      }
    } else if (this._isDefaultSendUp) {
      owner.removeEventListener('message', this._onBrowserMessage);
      this._isDefaultSendUp = false;
    }

    return this._onMessage;
  };

  CrossOriginTransactions.prototype.dispose = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var owner, _i, _a, id, t;

      return tslib.__generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            owner = this._owner();

            if (this._pingTimer) {
              owner.clearTimeout(this._pingTimer);
              this._pingTimer = undefined;
            }

            owner.removeEventListener('message', this._onBrowserMessage);
            owner.removeEventListener('pagehide', this._onPageHide);
            return [4
            /*yield*/
            , this._dead()];

          case 1:
            _b.sent();

            delete this._deadPromise;

            for (_i = 0, _a = Object.keys(this._transactions); _i < _a.length; _i++) {
              id = _a[_i];
              t = this._transactions[id];

              if (t.timer) {
                owner.clearTimeout(t.timer);
                delete t.timer;
              }

              t.transaction.end();
            }

            this._knownTargets = {};
            delete this.sendUp;
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  CrossOriginTransactions.prototype.beginTransaction = function (Transaction, value, timeout, sentTo, targetId, withReject) {
    var _this = this;

    if (!this._owner) {
      return getPromise(this._owner).reject();
    }

    var transaction = new Transaction(this._tabster, this._owner, this._knownTargets, value, timeout, sentTo, targetId, this.sendUp);
    var selfResponse;

    if (Transaction.shouldSelfRespond && Transaction.shouldSelfRespond(this._tabster, value, this._owner, this._ownerUId)) {
      selfResponse = function selfResponse(data) {
        return Transaction.makeResponse(_this._tabster, data, _this._owner, _this._ownerUId, _this, getPromise(_this._owner).resolve(undefined), true);
      };
    }

    return this._beginTransaction(transaction, timeout, selfResponse, withReject);
  };

  CrossOriginTransactions.prototype.removeTarget = function (uid) {
    delete this._knownTargets[uid];
  };

  CrossOriginTransactions.prototype._beginTransaction = function (transaction, timeout, selfResponse, withReject) {
    var _this = this;

    var owner = this._owner();

    var wrapper = {
      transaction: transaction,
      timer: owner.setTimeout(function () {
        delete wrapper.timer;
        transaction.end('Cross origin transaction timed out.');
      }, _transactionTimeout + (timeout || 0))
    };
    this._transactions[transaction.id] = wrapper;
    var ret = transaction.begin(selfResponse);
    ret["catch"](function () {})["finally"](function () {
      if (wrapper.timer) {
        owner.clearTimeout(wrapper.timer);
      }

      delete _this._transactions[transaction.id];
    });
    return ret.then(function (value) {
      return value;
    }, withReject ? undefined : function () {
      return undefined;
    });
  };

  CrossOriginTransactions.prototype.forwardTransaction = function (data) {
    var owner = this._owner;
    var targetId = data.target;

    if (targetId === this._ownerUId) {
      return getPromise(owner).resolve();
    }

    var Transaction = this._getTransactionClass(data.type);

    if (Transaction) {
      if (Transaction.shouldForward === undefined || Transaction.shouldForward(this._tabster, data, owner, this._ownerUId)) {
        var sentTo = data.sentto;

        if (targetId === _targetIdUp) {
          targetId = undefined;
          sentTo[this._ownerUId] = true;
        }

        delete sentTo[_targetIdUp];
        return this._beginTransaction(new Transaction(this._tabster, owner, this._knownTargets, data.beginData, data.timeout, sentTo, targetId, this.sendUp), data.timeout);
      } else {
        return getPromise(owner).resolve();
      }
    }

    return getPromise(owner).reject("Unknown transaction type " + data.type);
  };

  CrossOriginTransactions.prototype._getTransactionClass = function (type) {
    switch (type) {
      case CrossOriginTransactionTypes.Bootstrap:
        return BootstrapTransaction;

      case CrossOriginTransactionTypes.FocusElement:
        return FocusElementTransaction;

      case CrossOriginTransactionTypes.State:
        return StateTransaction;

      case CrossOriginTransactionTypes.GetElement:
        return GetElementTransaction;

      case CrossOriginTransactionTypes.RestoreFocusInDeloser:
        return RestoreFocusInDeloserTransaction;

      case CrossOriginTransactionTypes.Ping:
        return PingTransaction;

      default:
        return null;
    }
  };

  CrossOriginTransactions.prototype._dead = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {
              this._deadPromise = this.beginTransaction(StateTransaction, {
                ownerUId: this._ownerUId,
                state: CrossOriginStates.DeadWindow
              });
            }

            if (!this._deadPromise) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , this._deadPromise];

          case 1:
            _a.sent();

            _a.label = 2;

          case 2:
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  CrossOriginTransactions.prototype._ping = function () {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var deadWindows, now, targets, focused, deloserAPI;

      var _this = this;

      return tslib.__generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (this._pingTimer) {
              return [2
              /*return*/
              ];
            }

            now = Date.now();
            targets = Object.keys(this._knownTargets).filter(function (uid) {
              return now - (_this._knownTargets[uid].last || 0) > _pingTimeout;
            });

            if (this.sendUp) {
              targets.push(_targetIdUp);
            }

            if (!targets.length) return [3
            /*break*/
            , 2];
            return [4
            /*yield*/
            , getPromise(this._owner).all(targets.map(function (uid) {
              return _this.beginTransaction(PingTransaction, undefined, undefined, undefined, uid, true).then(function () {
                return true;
              }, function () {
                if (uid !== _targetIdUp) {
                  if (!deadWindows) {
                    deadWindows = {};
                  }

                  deadWindows[uid] = true;
                  delete _this._knownTargets[uid];
                }

                return false;
              });
            }))];

          case 1:
            _a.sent();

            _a.label = 2;

          case 2:
            if (!deadWindows) return [3
            /*break*/
            , 5];
            return [4
            /*yield*/
            , this.beginTransaction(GetElementTransaction, undefined)];

          case 3:
            focused = _a.sent();
            if (!(!focused && this.ctx.focusOwner && this.ctx.focusOwner in deadWindows)) return [3
            /*break*/
            , 5];
            return [4
            /*yield*/
            , this.beginTransaction(StateTransaction, {
              ownerUId: this._ownerUId,
              state: CrossOriginStates.Blurred,
              force: true
            })];

          case 4:
            _a.sent();

            deloserAPI = this._tabster.deloser;

            if (deloserAPI) {
              DeloserAPI.forceRestoreFocus(deloserAPI);
            }

            _a.label = 5;

          case 5:
            this._pingTimer = this._owner().setTimeout(function () {
              _this._pingTimer = undefined;

              _this._ping();
            }, _pingTimeout);
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  return CrossOriginTransactions;
}();

var CrossOriginElement = /*#__PURE__*/function () {
  function CrossOriginElement(tabster, uid, ownerId, id, rootId, observedName, observedDetails) {
    this._tabster = tabster;
    this.uid = uid;
    this.ownerId = ownerId;
    this.id = id;
    this.rootId = rootId;
    this.observedName = observedName;
    this.observedDetails = observedDetails;
  }

  CrossOriginElement.prototype.focus = function (noFocusedProgrammaticallyFlag, noAccessibleCheck) {
    return this._tabster.crossOrigin.focusedElement.focus(this, noFocusedProgrammaticallyFlag, noAccessibleCheck);
  };

  return CrossOriginElement;
}();

var CrossOriginFocusedElementState = /*#__PURE__*/function (_super) {
  tslib.__extends(CrossOriginFocusedElementState, _super);

  function CrossOriginFocusedElementState(transactions) {
    var _this = _super.call(this) || this;

    _this._transactions = transactions;
    return _this;
  }

  CrossOriginFocusedElementState.prototype.dispose = function () {
    _super.prototype.dispose.call(this);
  };

  CrossOriginFocusedElementState.dispose = function (instance) {
    instance.dispose();
  };

  CrossOriginFocusedElementState.prototype.focus = function (element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        return [2
        /*return*/
        , this._focus({
          uid: element.uid,
          id: element.id,
          rootId: element.rootId,
          ownerId: element.ownerId,
          observedName: element.observedName
        }, noFocusedProgrammaticallyFlag, noAccessibleCheck)];
      });
    });
  };

  CrossOriginFocusedElementState.prototype.focusById = function (elementId, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        return [2
        /*return*/
        , this._focus({
          id: elementId,
          rootId: rootId
        }, noFocusedProgrammaticallyFlag, noAccessibleCheck)];
      });
    });
  };

  CrossOriginFocusedElementState.prototype.focusByObservedName = function (observedName, timeout, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        return [2
        /*return*/
        , this._focus({
          observedName: observedName,
          rootId: rootId
        }, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout)];
      });
    });
  };

  CrossOriginFocusedElementState.prototype._focus = function (elementData, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        return [2
        /*return*/
        , this._transactions.beginTransaction(FocusElementTransaction, tslib.__assign(tslib.__assign({}, elementData), {
          noFocusedProgrammaticallyFlag: noFocusedProgrammaticallyFlag,
          noAccessibleCheck: noAccessibleCheck
        }), timeout).then(function (value) {
          return !!value;
        })];
      });
    });
  };

  CrossOriginFocusedElementState.setVal = function (instance, val, details) {
    instance.setVal(val, details);
  };

  return CrossOriginFocusedElementState;
}(Subscribable);

var CrossOriginObservedElementState = /*#__PURE__*/function (_super) {
  tslib.__extends(CrossOriginObservedElementState, _super);

  function CrossOriginObservedElementState(tabster, transactions) {
    var _this = _super.call(this) || this;

    _this._lastRequestFocusId = 0;
    _this._tabster = tabster;
    _this._transactions = transactions;
    return _this;
  }

  CrossOriginObservedElementState.prototype.dispose = function () {
    _super.prototype.dispose.call(this);
  };

  CrossOriginObservedElementState.dispose = function (instance) {
    instance.dispose();
  };

  CrossOriginObservedElementState.prototype.getElement = function (observedName, accessibility) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      return tslib.__generator(this, function (_a) {
        return [2
        /*return*/
        , this.waitElement(observedName, 0, accessibility)];
      });
    });
  };

  CrossOriginObservedElementState.prototype.waitElement = function (observedName, timeout, accessibility) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var _this = this;

      return tslib.__generator(this, function (_a) {
        return [2
        /*return*/
        , this._transactions.beginTransaction(GetElementTransaction, {
          observedName: observedName,
          accessibility: accessibility
        }, timeout).then(function (value) {
          return value ? StateTransaction.createElement(_this._tabster, value) : null;
        })];
      });
    });
  };

  CrossOriginObservedElementState.prototype.requestFocus = function (observedName, timeout) {
    return tslib.__awaiter(this, void 0, void 0, function () {
      var requestId;

      var _this = this;

      return tslib.__generator(this, function (_a) {
        requestId = ++this._lastRequestFocusId;
        return [2
        /*return*/
        , this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable).then(function (element) {
          return _this._lastRequestFocusId === requestId && element ? _this._tabster.crossOrigin.focusedElement.focus(element, true) : false;
        })];
      });
    });
  };

  CrossOriginObservedElementState.trigger = function (instance, element, details) {
    instance.trigger(element, details);
  };

  return CrossOriginObservedElementState;
}(Subscribable);

var CrossOriginAPI = /*#__PURE__*/function () {
  function CrossOriginAPI(tabster) {
    var _this = this;

    this._init = function () {
      _this._initTimer = undefined;
      var tabster = _this._tabster;
      tabster.keyboardNavigation.subscribe(_this._onKeyboardNavigationStateChanged);
      tabster.focusedElement.subscribe(_this._onFocus);
      tabster.observedElement.subscribe(_this._onObserved);

      if (!_this._ctx.origOutlineSetup) {
        _this._ctx.origOutlineSetup = tabster.outline.setup;
        tabster.outline.setup = _this._outlineSetup;
      }

      _this._transactions.beginTransaction(BootstrapTransaction, undefined, undefined, undefined, _targetIdUp).then(function (data) {
        if (data && _this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !== data.isNavigatingWithKeyboard) {
          _this._ctx.ignoreKeyboardNavigationStateUpdate = true;
          KeyboardNavigationState.setVal(_this._tabster.keyboardNavigation, data.isNavigatingWithKeyboard);
          _this._ctx.ignoreKeyboardNavigationStateUpdate = false;
        }
      });
    };

    this._onKeyboardNavigationStateChanged = function (value) {
      if (!_this._ctx.ignoreKeyboardNavigationStateUpdate) {
        _this._transactions.beginTransaction(StateTransaction, {
          state: CrossOriginStates.KeyboardNavigation,
          ownerUId: getWindowUId(_this._win()),
          isNavigatingWithKeyboard: value
        });
      }
    };

    this._onFocus = function (element, details) {
      var win = _this._win();

      var ownerUId = getWindowUId(win);

      if (_this._blurTimer) {
        win.clearTimeout(_this._blurTimer);
        _this._blurTimer = undefined;
      }

      if (element) {
        _this._transactions.beginTransaction(StateTransaction, tslib.__assign(tslib.__assign({}, GetElementTransaction.getElementData(_this._tabster, element, _this._win, _this._ctx, ownerUId)), {
          state: CrossOriginStates.Focused
        }));
      } else {
        _this._blurTimer = win.setTimeout(function () {
          _this._blurTimer = undefined;

          if (_this._ctx.focusOwner && _this._ctx.focusOwner === ownerUId) {
            _this._transactions.beginTransaction(GetElementTransaction, undefined).then(function (value) {
              if (!value && _this._ctx.focusOwner === ownerUId) {
                _this._transactions.beginTransaction(StateTransaction, {
                  ownerUId: ownerUId,
                  state: CrossOriginStates.Blurred,
                  force: false
                });
              }
            });
          }
        }, 0);
      }
    };

    this._onObserved = function (element, details) {
      var d = GetElementTransaction.getElementData(_this._tabster, element, _this._win, _this._ctx, getWindowUId(_this._win()));
      d.state = CrossOriginStates.Observed;
      d.observedName = details.name;
      d.observedDetails = details.details;

      _this._transactions.beginTransaction(StateTransaction, d);
    };

    this._outlineSetup = function (props) {
      _this._transactions.beginTransaction(StateTransaction, {
        state: CrossOriginStates.Outline,
        ownerUId: getWindowUId(_this._win()),
        outline: props
      });
    };

    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._ctx = {
      ignoreKeyboardNavigationStateUpdate: false,
      deloserByUId: {}
    };
    this._transactions = new CrossOriginTransactions(tabster, this._win, this._ctx);
    this.focusedElement = new CrossOriginFocusedElementState(this._transactions);
    this.observedElement = new CrossOriginObservedElementState(tabster, this._transactions);
  }

  CrossOriginAPI.prototype.setup = function (sendUp) {
    if (this.isSetUp()) {
      return this._transactions.setSendUp(sendUp);
    } else {
      this._initTimer = this._win().setTimeout(this._init, 0);
      return this._transactions.setup(sendUp);
    }
  };

  CrossOriginAPI.prototype.isSetUp = function () {
    return this._transactions.isSetUp;
  };

  CrossOriginAPI.prototype.dispose = function () {
    var _a;

    if (this._initTimer) {
      this._win().clearTimeout(this._initTimer);

      this._initTimer = undefined;
    }

    var tabster = this._tabster;
    tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);
    tabster.focusedElement.unsubscribe(this._onFocus);
    (_a = tabster.observedElement) === null || _a === void 0 ? void 0 : _a.unsubscribe(this._onObserved);

    this._transactions.dispose();

    CrossOriginFocusedElementState.dispose(this.focusedElement);
    CrossOriginObservedElementState.dispose(this.observedElement);
    this._ctx.deloserByUId = {};
  };

  CrossOriginAPI.dispose = function (instance) {
    instance.dispose();
  };

  return CrossOriginAPI;
}();

function getDeloserUID(getWindow, context, deloser) {
  var deloserElement = deloser.getElement();

  if (deloserElement) {
    var uid = getElementUId(getWindow, deloserElement);

    if (!context.deloserByUId[uid]) {
      context.deloserByUId[uid] = deloser;
    }

    return uid;
  }

  return undefined;
}

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

var _focusableSelector = /*#__PURE__*/['a[href]', 'button:not([disabled])', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', '*[tabindex]', '*[contenteditable]'].join(', ');

var FocusableAPI = /*#__PURE__*/function () {
  function FocusableAPI(tabster, getWindow) {
    this._tabster = tabster;
    this._win = getWindow;
  }

  FocusableAPI.prototype.dispose = function () {
    /**/
  };

  FocusableAPI.dispose = function (instance) {
    instance.dispose();
  };

  FocusableAPI.prototype._getBody = function () {
    var last = this._tabster.focusedElement.getLastFocusedElement();

    if (last && last.ownerDocument) {
      return last.ownerDocument.body;
    }

    return this._win().document.body;
  };

  FocusableAPI.prototype.getProps = function (element) {
    var tabsterOnElement = getTabsterOnElement(this._tabster, element);
    return tabsterOnElement && tabsterOnElement.focusable || {};
  };

  FocusableAPI.prototype.isFocusable = function (el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {
    if (matchesSelector(el, _focusableSelector) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {
      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));
    }

    return false;
  };

  FocusableAPI.prototype.isVisible = function (el) {
    if (!el.ownerDocument) {
      return false;
    }

    if (el.offsetParent === null && el.ownerDocument.body !== el) {
      return false;
    }

    var win = el.ownerDocument.defaultView;

    if (!win) {
      return false;
    }

    var rect = el.ownerDocument.body.getBoundingClientRect();

    if (rect.width === 0 && rect.height === 0) {
      // This might happen, for example, if our <body> is in hidden <iframe>.
      return false;
    }

    var computedStyle = win.getComputedStyle(el);

    if (computedStyle.visibility === 'hidden') {
      return false;
    }

    return true;
  };

  FocusableAPI.prototype.isAccessible = function (el) {
    var _a;

    for (var e = el; e; e = e.parentElement) {
      var tabsterOnElement = getTabsterOnElement(this._tabster, e);

      if (this._isHidden(e)) {
        return false;
      }

      var ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;

      if (!ignoreDisabled && this._isDisabled(e)) {
        return false;
      }
    }

    return true;
  };

  FocusableAPI.prototype._isDisabled = function (el) {
    return el.hasAttribute('disabled');
  };

  FocusableAPI.prototype._isHidden = function (el) {
    var attrVal = el.getAttribute('aria-hidden');

    if (attrVal && attrVal.toLowerCase() === 'true') {
      return true;
    }

    return false;
  };

  FocusableAPI.prototype.findFirst = function (options) {
    return this.findElement(tslib.__assign({
      container: this._getBody()
    }, options));
  };

  FocusableAPI.prototype.findLast = function (options) {
    return this.findElement(tslib.__assign({
      container: this._getBody(),
      prev: true
    }, options));
  };

  FocusableAPI.prototype.findNext = function (options) {
    return this.findElement(tslib.__assign({
      container: this._getBody()
    }, options));
  };

  FocusableAPI.prototype.findPrev = function (options) {
    return this.findElement(tslib.__assign({
      container: this._getBody(),
      prev: true
    }, options));
  };

  FocusableAPI.prototype.findDefault = function (options) {
    var _this = this;

    return this.findElement(tslib.__assign(tslib.__assign({}, options), {
      acceptCondition: function acceptCondition(el) {
        return _this._tabster.focusable.isFocusable(el, options.includeProgrammaticallyFocusable) && !!_this.getProps(el).isDefault;
      }
    })) || null;
  };

  FocusableAPI.prototype.findAll = function (options) {
    var _this = this;

    var container = options.container,
        customAcceptCondition = options.acceptCondition,
        includeProgrammaticallyFocusable = options.includeProgrammaticallyFocusable,
        ignoreGroupper = options.ignoreGroupper,
        ignoreUncontrolled = options.ignoreUncontrolled,
        ignoreAccessibiliy = options.ignoreAccessibiliy,
        skipDefaultCheck = options.skipDefaultCheck;

    var acceptCondition = function acceptCondition(el) {
      var defaultCheck;
      var customCheck = false;

      if (skipDefaultCheck) {
        defaultCheck = true;
      } else {
        defaultCheck = _this._tabster.focusable.isFocusable(el, includeProgrammaticallyFocusable);
      }

      if (defaultCheck) {
        customCheck = customAcceptCondition ? customAcceptCondition(el) : true;
      }

      return defaultCheck && customCheck;
    };

    var acceptElementState = {
      container: container,
      from: null,
      isForward: true,
      acceptCondition: acceptCondition,
      includeProgrammaticallyFocusable: includeProgrammaticallyFocusable,
      ignoreGroupper: ignoreGroupper,
      ignoreUncontrolled: ignoreUncontrolled,
      ignoreAccessibiliy: ignoreAccessibiliy,
      grouppers: {}
    };
    var walker = createElementTreeWalker(container.ownerDocument, container, function (node) {
      return _this._acceptElement(node, acceptElementState);
    });
    var nodeFilter = walker === null || walker === void 0 ? void 0 : walker.filter;

    if (!walker || !nodeFilter) {
      return [];
    }

    var foundNodes = [];
    var node;

    while (node = walker.nextNode()) {
      foundNodes.push(node);
    }

    return foundNodes;
  };

  FocusableAPI.prototype.findElement = function (options) {
    var _this = this;

    var container = options.container,
        _a = options.currentElement,
        currentElement = _a === void 0 ? null : _a,
        includeProgrammaticallyFocusable = options.includeProgrammaticallyFocusable,
        ignoreGroupper = options.ignoreGroupper,
        ignoreUncontrolled = options.ignoreUncontrolled,
        ignoreAccessibiliy = options.ignoreAccessibiliy,
        prev = options.prev,
        onUncontrolled = options.onUncontrolled;
    var acceptCondition = options.acceptCondition;

    if (!container) {
      return null;
    }

    if (!container.ownerDocument || currentElement && container !== currentElement && !container.contains(currentElement)) {
      return null;
    }

    if (!acceptCondition) {
      acceptCondition = function acceptCondition(el) {
        return _this._tabster.focusable.isFocusable(el, includeProgrammaticallyFocusable, ignoreAccessibiliy, ignoreAccessibiliy);
      };
    }

    var acceptElementState = {
      container: container,
      from: currentElement,
      isForward: !prev,
      acceptCondition: acceptCondition,
      includeProgrammaticallyFocusable: includeProgrammaticallyFocusable,
      ignoreGroupper: ignoreGroupper,
      ignoreUncontrolled: ignoreUncontrolled,
      ignoreAccessibiliy: ignoreAccessibiliy,
      grouppers: {}
    };
    var walker = createElementTreeWalker(container.ownerDocument, container, function (node) {
      return _this._acceptElement(node, acceptElementState);
    });

    if (!walker) {
      return null;
    }

    if (currentElement) {
      walker.currentNode = currentElement;
    } else if (prev) {
      var lastChild = getLastChild(container);

      if (!lastChild) {
        return null;
      }

      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT) {
        return lastChild;
      } else {
        walker.currentNode = lastChild;
      }
    }

    var foundElement = prev ? walker.previousNode() : walker.nextNode();
    var nextUncontrolled = acceptElementState.nextUncontrolled;

    if (nextUncontrolled) {
      if (foundElement) {
        // We have an uncontrolled area and there is a controlled element after it.
        // Return undefined for the default Tab action.
        foundElement = undefined;
      } else {
        // Otherwise, return null to moveOutWithDefaultAction().
        foundElement = null;
      }

      if (onUncontrolled) {
        onUncontrolled(nextUncontrolled);
      }
    }

    return acceptElementState.found ? acceptElementState.foundElement : foundElement;
  };

  FocusableAPI.prototype._acceptElement = function (element, state) {
    if (element === state.container) {
      return NodeFilter.FILTER_SKIP;
    }

    if (state.found) {
      return NodeFilter.FILTER_ACCEPT;
    }

    var ctx = RootAPI.getTabsterContext(this._tabster, element); // Tabster is opt in, if it is not managed, don't try and get do anything special

    if (!ctx) {
      return NodeFilter.FILTER_SKIP;
    }

    if (state.ignoreUncontrolled) {
      if (shouldIgnoreFocus(element)) {
        return NodeFilter.FILTER_SKIP;
      }
    } else if (ctx.groupper) {
      state.nextGroupper = ctx.groupper.getElement();
    } else if (ctx.mover) {
      state.nextMover = ctx.mover.getElement();
    } else if (ctx.uncontrolled && !state.nextUncontrolled) {
      if (!ctx.groupper && !ctx.mover) {
        state.nextUncontrolled = ctx.uncontrolled;
        return NodeFilter.FILTER_REJECT;
      }
    } // We assume iframes are focusable because native tab behaviour would tab inside


    if (element.tagName === 'IFRAME') {
      return NodeFilter.FILTER_ACCEPT;
    }

    if (!state.ignoreAccessibiliy && !this.isAccessible(element)) {
      return NodeFilter.FILTER_REJECT;
    }

    if (!state.ignoreGroupper) {
      var groupper = void 0;
      var mover = void 0;
      groupper = ctx.groupper;
      mover = ctx.mover;
      var isGroupperFirst = ctx.isGroupperFirst;

      if (groupper && isGroupperFirst) {
        mover = undefined;
      } else if (mover && !isGroupperFirst) {
        groupper = undefined;
      }

      if (groupper) {
        var result = groupper.acceptElement(element, state);

        if (result !== undefined) {
          return result;
        }
      }

      if (mover) {
        var result = mover.acceptElement(element, state);

        if (result !== undefined) {
          return result;
        }
      }
    }

    return state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  };

  return FocusableAPI;
}();

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Keys = {
  Tab: 9,
  Enter: 13,
  Esc: 27,
  Space: 32,
  PageUp: 33,
  PageDown: 34,
  End: 35,
  Home: 36,
  Left: 37,
  Up: 38,
  Right: 39,
  Down: 40
};

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

var FocusedElementState = /*#__PURE__*/function (_super) {
  tslib.__extends(FocusedElementState, _super);

  function FocusedElementState(tabster, getWindow) {
    var _this = _super.call(this) || this;

    _this._init = function () {
      _this._initTimer = undefined;

      var win = _this._win(); // Add these event listeners as capture - we want Tabster to run before user event handlers


      win.document.addEventListener(keyborg.KEYBORG_FOCUSIN, _this._onFocusIn, true);
      win.document.addEventListener('focusout', _this._onFocusOut, true);

      if (_this._tabster.controlTab) {
        win.addEventListener('keydown', _this._onKeyDown, true);
      }
    };

    _this._onFocusIn = function (e) {
      _this._setFocusedElement(e.target, e.details.relatedTarget || undefined, e.details.isFocusedProgrammatically);
    };

    _this._onFocusOut = function (e) {
      _this._setFocusedElement(undefined, e.relatedTarget || undefined);
    };

    _this._validateFocusedElement = function (element) {// TODO: Make sure this is not needed anymore and write tests.
    };

    _this._onKeyDown = function (e) {
      var _a;

      if (e.keyCode !== Keys.Tab) {
        return;
      }

      var curElement = _this.getVal();

      if (!curElement || !curElement.ownerDocument || curElement.contentEditable === 'true') {
        return;
      }

      var ctx = RootAPI.getTabsterContext(_this._tabster, curElement, {
        checkRtl: true
      });

      if (!ctx) {
        return;
      }

      var isPrev = e.shiftKey;
      var next = FocusedElementState.findNextTabbable(_this._tabster, ctx, curElement, isPrev);

      if (!next) {
        return;
      }

      var uncontrolled = next.uncontrolled;

      if (uncontrolled) {
        if (!ctx.uncontrolled) {
          // We have met an uncontrolled area, just allow default action.
          _this._moveToUncontrolled(uncontrolled, isPrev);
        }

        return;
      }

      var nextElement = next.element;

      if (ctx.modalizer) {
        var nextElementCtx = nextElement && RootAPI.getTabsterContext(_this._tabster, nextElement);

        if (!nextElementCtx || ctx.root.uid !== nextElementCtx.root.uid || !((_a = nextElementCtx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {
          if (ctx.modalizer.onBeforeFocusOut()) {
            e.preventDefault();
            return;
          }
        }
      }

      if (nextElement) {
        // For iframes just allow normal Tab behaviour
        if (nextElement.tagName !== 'IFRAME') {
          e.preventDefault();
          keyborg.nativeFocus(nextElement);
        }
      } else {
        ctx.root.moveOutWithDefaultAction(isPrev);
      }
    };

    _this._tabster = tabster;
    _this._win = getWindow;
    _this._initTimer = getWindow().setTimeout(_this._init, 0);
    return _this;
  }

  FocusedElementState.prototype.dispose = function () {
    _super.prototype.dispose.call(this);

    var win = this._win();

    if (this._initTimer) {
      win.clearTimeout(this._initTimer);
      this._initTimer = undefined;
    }

    win.document.removeEventListener(keyborg.KEYBORG_FOCUSIN, this._onFocusIn, true);
    win.document.removeEventListener('focusout', this._onFocusOut, true);

    if (this._tabster.controlTab) {
      win.addEventListener('keydown', this._onKeyDown, true);
    }

    delete FocusedElementState._lastResetElement;
    delete this._nextVal;
    delete this._lastVal;
  };

  FocusedElementState.dispose = function (instance) {
    instance.dispose();
  };

  FocusedElementState.forgetMemorized = function (instance, parent) {
    var _a, _b;

    var wel = FocusedElementState._lastResetElement;
    var el = wel && wel.get();

    if (el && parent.contains(el)) {
      delete FocusedElementState._lastResetElement;
    }

    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();

    if (el && parent.contains(el)) {
      delete instance._nextVal;
    }

    wel = instance._lastVal;
    el = wel && wel.get();

    if (el && parent.contains(el)) {
      delete instance._lastVal;
    }
  };

  FocusedElementState.prototype.getFocusedElement = function () {
    return this.getVal();
  };

  FocusedElementState.prototype.getLastFocusedElement = function () {
    var _a;

    var el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();

    if (!el || el && !documentContains(el.ownerDocument, el)) {
      this._lastVal = el = undefined;
    }

    return el;
  };

  FocusedElementState.prototype.focus = function (element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {
    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {
      return false;
    }

    element.focus();
    return true;
  };

  FocusedElementState.prototype.focusDefault = function (container) {
    var el = this._tabster.focusable.findDefault({
      container: container
    });

    if (el) {
      this._tabster.focusedElement.focus(el);

      return true;
    }

    return false;
  };

  FocusedElementState.prototype.focusFirst = function (props) {
    var container = props.container;
    var toFocus;

    if (container) {
      var ctx = RootAPI.getTabsterContext(this._tabster, container, {
        checkRtl: true
      });

      if (ctx) {
        var next = FocusedElementState.findNextTabbable(this._tabster, ctx, container);

        if (next && !next.uncontrolled) {
          toFocus = next.element;
        }
      }
    }

    if (!toFocus) {
      toFocus = this._tabster.focusable.findFirst(props);

      if (!toFocus) {
        toFocus = this._tabster.focusable.findFirst(tslib.__assign(tslib.__assign({}, props), {
          ignoreUncontrolled: true,
          ignoreAccessibiliy: true
        }));
      }
    }

    if (toFocus) {
      this.focus(toFocus, false, true);
      return true;
    }

    return false;
  };

  FocusedElementState.prototype.focusLast = function (props) {
    var container = props.container;
    var toFocus;

    if (container) {
      var ctx = RootAPI.getTabsterContext(this._tabster, container, {
        checkRtl: true
      });

      if (ctx) {
        var next = FocusedElementState.findNextTabbable(this._tabster, ctx, getLastChild(container), true);

        if (next && !next.uncontrolled) {
          toFocus = next.element;
        }
      }
    }

    if (!toFocus) {
      toFocus = this._tabster.focusable.findLast(props);

      if (!toFocus) {
        toFocus = this._tabster.focusable.findLast(tslib.__assign(tslib.__assign({}, props), {
          ignoreUncontrolled: true,
          ignoreAccessibiliy: true
        }));
      }
    }

    if (toFocus) {
      this.focus(toFocus, false, true);
      return true;
    }

    return false;
  };

  FocusedElementState.prototype.resetFocus = function (container) {
    if (!this._tabster.focusable.isVisible(container)) {
      return false;
    }

    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {
      var prevTabIndex = container.getAttribute('tabindex');
      var prevAriaHidden = container.getAttribute('aria-hidden');
      container.tabIndex = -1;
      container.setAttribute('aria-hidden', 'true');
      FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);
      this.focus(container, true, true);

      this._setOrRemoveAttribute(container, 'tabindex', prevTabIndex);

      this._setOrRemoveAttribute(container, 'aria-hidden', prevAriaHidden);
    } else {
      this.focus(container);
    }

    return true;
  };

  FocusedElementState.prototype._setOrRemoveAttribute = function (element, name, value) {
    if (value === null) {
      element.removeAttribute(name);
    } else {
      element.setAttribute(name, value);
    }
  };

  FocusedElementState.prototype._setFocusedElement = function (element, relatedTarget, isFocusedProgrammatically) {
    var _a;

    if (this._tabster._noop) {
      return;
    }

    var details = {
      relatedTarget: relatedTarget
    };

    if (element) {
      var lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();
      FocusedElementState._lastResetElement = undefined;

      if (lastResetElement === element || shouldIgnoreFocus(element)) {
        return;
      }

      details.isFocusedProgrammatically = isFocusedProgrammatically;
    }

    var nextVal = this._nextVal = {
      element: element ? new WeakHTMLElement(this._win, element) : undefined,
      details: details
    };

    if (element && element !== this._val) {
      this._validateFocusedElement(element);
    } // _validateFocusedElement() might cause the refocus which will trigger
    // another call to this function. Making sure that the value is correct.


    if (this._nextVal === nextVal) {
      this.setVal(element, details);
    }

    this._nextVal = undefined;
  };

  FocusedElementState.prototype.setVal = function (val, details) {
    _super.prototype.setVal.call(this, val, details);

    if (val) {
      this._lastVal = new WeakHTMLElement(this._win, val);
    }
  };

  FocusedElementState.findNextTabbable = function (tabster, ctx, from, prev) {
    var next = null;
    var current;

    if (from) {
      current = from;
    } else {
      var container = ctx.root.getElement();

      if (container) {
        current = getLastChild(container) || container;
      } else {
        return null;
      }
    }

    if (ctx.groupper && ctx.mover) {
      if (ctx.isGroupperFirst) {
        next = ctx.groupper.findNextTabbable(current, prev);

        if (next === null) {
          next = ctx.mover.findNextTabbable(current, prev);
        }
      } else {
        next = ctx.mover.findNextTabbable(current, prev);

        if (next === null) {
          next = ctx.groupper.findNextTabbable(current, prev);
        }
      }
    } else if (ctx.groupper) {
      next = ctx.groupper.findNextTabbable(current, prev);
    } else if (ctx.mover) {
      next = ctx.mover.findNextTabbable(current, prev);
    } else {
      var uncontrolled_1;

      var onUncontrolled = function onUncontrolled(el) {
        uncontrolled_1 = el;
      };

      var nextElement = prev ? tabster.focusable.findPrev({
        currentElement: current,
        onUncontrolled: onUncontrolled
      }) : tabster.focusable.findNext({
        currentElement: current,
        onUncontrolled: onUncontrolled
      });
      next = {
        element: nextElement,
        uncontrolled: uncontrolled_1
      };
    }

    return next;
  };

  FocusedElementState.prototype._moveToUncontrolled = function (uncontrolled, isPrev) {
    var dummy = new DummyInput(this._win, {
      isPhantom: true,
      isFirst: true
    });
    var input = dummy.input;

    if (input) {
      var parent_1 = uncontrolled.parentElement;

      if (parent_1) {
        parent_1.insertBefore(input, isPrev ? uncontrolled.nextElementSibling : uncontrolled);
        keyborg.nativeFocus(input);
      }
    }
  };

  return FocusedElementState;
}(Subscribable);

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

var GroupperDummyManager = /*#__PURE__*/function (_super) {
  tslib.__extends(GroupperDummyManager, _super);

  function GroupperDummyManager(element, tabster) {
    var _this = _super.call(this, tabster, element) || this;

    _this._onFocusDummyInput = function (dummyInput) {
      var container = _this._element.get();

      if (container && !dummyInput.shouldMoveOut) {
        if (dummyInput.isFirst) {
          _this._tabster.focusedElement.focusFirst({
            container: container
          });
        } else {
          _this._tabster.focusedElement.focusLast({
            container: container
          });
        }
      }
    };

    _this._tabster = tabster;
    _this.firstDummy.onFocusIn = _this._onFocusDummyInput;
    _this.lastDummy.onFocusIn = _this._onFocusDummyInput;
    return _this;
  }

  return GroupperDummyManager;
}(DummyInputManager);

var Groupper = /*#__PURE__*/function (_super) {
  tslib.__extends(Groupper, _super);

  function Groupper(tabster, element, props) {
    var _this = _super.call(this, tabster, element, props) || this;

    _this._shouldTabInside = false;

    _this.makeTabbable(false);

    if (!tabster.controlTab) {
      _this._dummyManager = new GroupperDummyManager(_this._element, tabster);
    }

    return _this;
  }

  Groupper.prototype.dispose = function () {
    var _a;

    var element = this._element.get();

    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();

    if (element) {
      {
        _setInformativeStyle$2(this._element, true);
      }
    }

    delete this._first;
  };

  Groupper.prototype.findNextTabbable = function (current, prev) {
    var container = this.getElement();

    if (!container || !container.contains(current)) {
      return null;
    }

    var tabster = this._tabster;
    var next = null;
    var uncontrolled;

    var onUncontrolled = function onUncontrolled(el) {
      uncontrolled = el;
    };

    if (this._shouldTabInside) {
      var groupperFirstFocusable = this.getFirst();

      if (groupperFirstFocusable) {
        var findSiblingFrom = prev ? groupperFirstFocusable : getLastChild(groupperFirstFocusable);
        var actualContainer = void 0;

        if (findSiblingFrom) {
          var firstFocusableSibling = prev ? tabster.focusable.findPrev({
            container: container,
            currentElement: findSiblingFrom,
            ignoreUncontrolled: true
          }) : tabster.focusable.findNext({
            container: container,
            currentElement: findSiblingFrom,
            ignoreUncontrolled: true
          });
          actualContainer = firstFocusableSibling ? container : groupperFirstFocusable;
        } else {
          actualContainer = container;
        }

        if (actualContainer) {
          next = prev ? tabster.focusable.findPrev({
            container: actualContainer,
            currentElement: current,
            onUncontrolled: onUncontrolled
          }) : tabster.focusable.findNext({
            container: actualContainer,
            currentElement: current,
            onUncontrolled: onUncontrolled
          });

          if (!uncontrolled && !next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {
            next = prev ? tabster.focusable.findLast({
              container: actualContainer
            }) : tabster.focusable.findFirst({
              container: actualContainer
            });
          }
        }
      }
    }

    if (next === null) {
      var parentElement = container.parentElement;

      if (parentElement) {
        var parentCtx = RootAPI.getTabsterContext(tabster, parentElement);

        if (parentCtx) {
          return FocusedElementState.findNextTabbable(tabster, parentCtx, current, prev);
        }
      }
    }

    return {
      element: next,
      uncontrolled: uncontrolled
    };
  };

  Groupper.prototype.makeTabbable = function (isTabbable) {
    this._shouldTabInside = isTabbable;

    {
      _setInformativeStyle$2(this._element, !this._shouldTabInside);
    }
  };

  Groupper.prototype.shouldTabInside = function () {
    return this._shouldTabInside;
  };

  Groupper.prototype.isActive = function () {
    var _a;

    var element = this.getElement() || null;
    var isParentActive = true;

    for (var e = element === null || element === void 0 ? void 0 : element.parentElement; e; e = e.parentElement) {
      var g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;

      if (g) {
        if (!g._shouldTabInside) {
          isParentActive = false;
        }
      }
    }

    return isParentActive ? this._props.tabbability ? this._shouldTabInside : false : undefined;
  };

  Groupper.prototype.getFirst = function () {
    var _a;

    var groupperElement = this.getElement();
    var first;

    if (groupperElement) {
      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();

      if (!first) {
        first = (this._tabster.focusable.isFocusable(groupperElement) ? groupperElement : this._tabster.focusable.findFirst({
          container: groupperElement,
          ignoreUncontrolled: true
        })) || undefined;
      }
    }

    return first;
  };

  Groupper.prototype.setFirst = function (element) {
    if (element) {
      this._first = new WeakHTMLElement(this._tabster.getWindow, element);
    } else {
      delete this._first;
    }
  };

  Groupper.prototype.acceptElement = function (element, state) {
    var grouppers = state.grouppers,
        container = state.container;
    var cached = grouppers[this.id];

    if (!cached) {
      var isActive = this.isActive();
      var groupperElement = this.getElement();

      if (groupperElement) {
        var isInside = groupperElement !== container && container.contains(groupperElement);
        cached = grouppers[this.id] = {
          isInside: isInside,
          isActive: isActive
        };

        if (isInside && isActive !== true) {
          var first = this.getFirst();

          if (first && state.acceptCondition(first)) {
            var focused = this._tabster.focusedElement.getFocusedElement();

            cached.first = first;

            if (focused) {
              this.setFirst(groupperElement.contains(focused) ? undefined : first);
            }
          }
        }
      }
    }

    if (cached.isInside) {
      if (cached.isActive === undefined) {
        return NodeFilter.FILTER_REJECT;
      } else if (cached.isActive === false) {
        return cached.first === element ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    }

    return undefined;
  };

  return Groupper;
}(TabsterPart);

var GroupperAPI = /*#__PURE__*/function () {
  function GroupperAPI(tabster, getWindow) {
    var _this = this;

    this._current = {};

    this._init = function () {
      _this._initTimer = undefined;

      var win = _this._win();

      _this._tabster.focusedElement.subscribe(_this._onFocus);

      win.document.addEventListener('mousedown', _this._onMouseDown, true);
      win.addEventListener('keydown', _this._onKeyDown, true);
    };

    this._onFocus = function (element) {
      if (element) {
        _this._updateCurrent(element, false, true);
      }
    };

    this._onMouseDown = function (e) {
      if (e.target) {
        _this._updateCurrent(e.target, true);
      }
    };

    this._onKeyDown = function (e) {
      var _a, _b, _c;

      if (e.keyCode !== Keys.Enter && e.keyCode !== Keys.Esc && e.keyCode !== Keys.Tab) {
        return;
      }

      var isPrev = e.shiftKey;

      var element = _this._tabster.focusedElement.getFocusedElement();

      if (element) {
        var ctx = RootAPI.getTabsterContext(_this._tabster, element);
        var groupper = ctx === null || ctx === void 0 ? void 0 : ctx.groupper;

        if (ctx && groupper) {
          var next = void 0;

          if (e.keyCode === Keys.Enter) {
            var groupperFirstFocusable = groupper.getFirst();

            if (groupperFirstFocusable !== element || groupper.isActive()) {
              return;
            }

            next = _this._tabster.focusable.findFirst({
              container: groupperFirstFocusable,
              ignoreGroupper: true
            });

            if (next) {
              _this._updateCurrent(next);
            }
          } else if (e.keyCode === Keys.Esc) {
            for (var e_1 = element; e_1; e_1 = e_1.parentElement) {
              var g = (_a = getTabsterOnElement(_this._tabster, e_1)) === null || _a === void 0 ? void 0 : _a.groupper;

              if (g && (g.isActive() || !g.getProps().tabbability)) {
                g.makeTabbable(false);
                next = g.getFirst();

                if (next) {
                  break;
                }
              }
            }
          } else if (e.keyCode === Keys.Tab && !_this._tabster.controlTab) {
            next = (_b = FocusedElementState.findNextTabbable(_this._tabster, ctx, element, isPrev)) === null || _b === void 0 ? void 0 : _b.element;
          }

          if (next) {
            e.preventDefault();
            keyborg.nativeFocus(next);
          } else {
            (_c = groupper._dummyManager) === null || _c === void 0 ? void 0 : _c.moveOutWithDefaultAction(isPrev);
          }
        }
      }
    };

    this._tabster = tabster;
    this._win = getWindow;
    this._initTimer = getWindow().setTimeout(this._init, 0);
  }

  GroupperAPI.prototype.dispose = function () {
    var win = this._win();

    this._current = {};

    if (this._initTimer) {
      win.clearTimeout(this._initTimer);
      this._initTimer = undefined;
    }

    this._tabster.focusedElement.unsubscribe(this._onFocus);

    win.document.removeEventListener('mousedown', this._onMouseDown, true);
    win.removeEventListener('keydown', this._onKeyDown, true);
  };

  GroupperAPI.dispose = function (instance) {
    instance.dispose();
  };

  GroupperAPI.prototype.forgetCurrentGrouppers = function () {
    this._current = {};
  };

  GroupperAPI.prototype._updateCurrent = function (element, includeTarget, checkTarget) {
    var _a;

    var newIds = {};
    var isTarget = true;

    for (var el = element; el; el = el.parentElement) {
      var groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;

      if (groupper) {
        newIds[groupper.id] = true;

        if (isTarget && checkTarget && !groupper.shouldTabInside() && (!groupper.getProps().tabbability || el !== element && (this._tabster.focusable.isFocusable(el) || element !== groupper.getFirst()))) {
          isTarget = false;
        }

        if (includeTarget || !isTarget) {
          this._current[groupper.id] = groupper;
          groupper.makeTabbable(true);
        }

        isTarget = false;
      }
    }

    for (var _i = 0, _b = Object.keys(this._current); _i < _b.length; _i++) {
      var id = _b[_i];
      var groupper = this._current[id];

      if (!(groupper.id in newIds)) {
        groupper.makeTabbable(false);
        groupper.setFirst(undefined);
        delete this._current[id];
      }
    }
  };

  GroupperAPI.createGroupper = function (tabster, element, props) {

    return new Groupper(tabster, element, props);
  };

  return GroupperAPI;
}();

function _setInformativeStyle$2(weakElement, remove) {
  {
    var element = weakElement.get();

    if (element) {
      if (remove) {
        element.style.removeProperty('--tabster-groupper');
      } else {
        element.style.setProperty('--tabster-groupper', 'unlimited');
      }
    }
  }
}

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _lastInternalId = 0;

function _setInformativeStyle$3(weakElement, remove, internalId, userId, isActive, isFocused) {
  {
    var element = weakElement.get();

    if (element) {
      if (remove) {
        element.style.removeProperty('--tabster-modalizer');
      } else {
        element.style.setProperty('--tabster-modalizer', internalId + ',' + userId + ',' + (isActive ? 'active' : 'inactive') + ',' + ',' + (isFocused ? 'focused' : 'not-focused'));
      }
    }
  }
}

var Modalizer = /*#__PURE__*/function (_super) {
  tslib.__extends(Modalizer, _super);

  function Modalizer(tabster, element, onDispose, moveOutWithDefault, onActiveChange, props) {
    var _this = _super.call(this, tabster, element, props) || this;

    _this._isFocused = false;

    _this._onKeyDown = function (e) {
      var keyCode = e.keyCode;
      var isPrev = e.shiftKey;

      if (keyCode !== Keys.Tab) {
        return;
      }

      var focusedElement = _this._tabster.focusedElement.getFocusedElement();

      var modalizerElement = _this.getElement();

      var findFn = isPrev ? 'findPrev' : 'findNext';
      var next;

      if (focusedElement && (modalizerElement === null || modalizerElement === void 0 ? void 0 : modalizerElement.contains(focusedElement))) {
        next = _this._tabster.focusable[findFn]({
          container: _this.getElement(),
          currentElement: focusedElement
        });
      }

      if (next) {
        e.preventDefault();
        keyborg.nativeFocus(next);
      } else if (!_this._props.isOthersAccessible) {
        _this._moveOutWithDefault(isPrev);
      }
    };

    _this.internalId = 'ml' + ++_lastInternalId;
    _this.userId = props.id;
    _this._onDispose = onDispose;
    _this._moveOutWithDefault = moveOutWithDefault;
    _this._onActiveChange = onActiveChange;
    element.addEventListener('keydown', _this._onKeyDown);
    var parentElement = element.parentElement;

    if (parentElement) {
      _this._modalizerParent = new WeakHTMLElement(tabster.getWindow, parentElement);
    } else {
      _this._modalizerParent = null;
    }

    _this._setAccessibilityProps();

    {
      _setInformativeStyle$3(_this._element, false, _this.internalId, _this.userId, _this._isActive, _this._isFocused);
    }

    return _this;
  }

  Modalizer.prototype.setProps = function (props) {
    if (props.id) {
      this.userId = props.id;
    }

    this._props = tslib.__assign({}, props);

    this._setAccessibilityProps();
  };

  Modalizer.prototype.dispose = function () {
    this._onDispose(this);

    this._remove();
  };

  Modalizer.prototype.setActive = function (active) {
    var _this = this;

    var _a, _b, _c;

    if (active === this._isActive) {
      return;
    }

    this._isActive = active;

    this._onActiveChange(active);

    {
      _setInformativeStyle$3(this._element, false, this.internalId, this.userId, this._isActive, this._isFocused);
    }

    var targetDocument = ((_a = this._element.get()) === null || _a === void 0 ? void 0 : _a.ownerDocument) || ((_c = (_b = this._modalizerParent) === null || _b === void 0 ? void 0 : _b.get()) === null || _c === void 0 ? void 0 : _c.ownerDocument); // Document can't be determined frm the modalizer root or its parent, fallback to window

    if (!targetDocument) {
      targetDocument = this._tabster.getWindow().document;
    }

    var root = targetDocument.body; // Sets or restores aria-hidden value based on `active` flag

    var ariaHiddenWalker = createElementTreeWalker(targetDocument, root, function (el) {
      var _a; // if other content should be accessible no need to do walk the tree


      if (_this._props.isOthersAccessible) {
        return NodeFilter.FILTER_REJECT;
      }

      var modalizerRoot = _this._element.get();

      var modalizerParent = (_a = _this._modalizerParent) === null || _a === void 0 ? void 0 : _a.get();
      var isModalizerElement = modalizerRoot === el;
      var containsModalizerRoot = !!el.contains(modalizerRoot || null);
      var containsModalizerParent = !!el.contains(modalizerParent || null);

      if (isModalizerElement) {
        return NodeFilter.FILTER_REJECT;
      }

      if (containsModalizerRoot || containsModalizerParent) {
        return NodeFilter.FILTER_SKIP;
      } // Add `aria-hidden` when modalizer is active
      // Restore `aria-hidden` when modalizer is inactive


      augmentAttribute(_this._tabster, el, 'aria-hidden', active ? 'true' : undefined);
      var modalizerRootOnPage = modalizerRoot === (modalizerRoot === null || modalizerRoot === void 0 ? void 0 : modalizerRoot.ownerDocument.body) ? false : modalizerRoot === null || modalizerRoot === void 0 ? void 0 : modalizerRoot.ownerDocument.body.contains(modalizerRoot);
      var modalizerParentOnPage = modalizerParent === (modalizerParent === null || modalizerParent === void 0 ? void 0 : modalizerParent.ownerDocument.body) ? false : modalizerParent === null || modalizerParent === void 0 ? void 0 : modalizerParent.ownerDocument.body.contains(modalizerParent); // if the modalizer root or its parent is not on the page, all nodes need to be visited

      if (!modalizerParentOnPage && !modalizerRootOnPage) {
        return NodeFilter.FILTER_SKIP;
      }

      return NodeFilter.FILTER_REJECT;
    });

    if (ariaHiddenWalker) {
      while (ariaHiddenWalker.nextNode()) {
        /** Iterate to update the tree */
      }
    }
  };

  Modalizer.prototype.isActive = function () {
    return !!this._isActive;
  };

  Modalizer.prototype.contains = function (element) {
    var _a;

    return !!((_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.contains(element));
  };

  Modalizer.prototype.onBeforeFocusOut = function () {
    var element = this.getElement();
    return element ? !triggerEvent(element, ModalizerEventName, {
      eventName: 'beforefocusout'
    }) : false;
  };

  Modalizer.prototype._remove = function () {
    {
      _setInformativeStyle$3(this._element, true);
    }
  };

  Modalizer.prototype._setAccessibilityProps = function () {
    var _a;

    {
      if (!((_a = this._element.get()) === null || _a === void 0 ? void 0 : _a.getAttribute('aria-label'))) {
        console.error('Modalizer element must have aria-label', this._element.get());
      }
    }
  };

  return Modalizer;
}(TabsterPart);
/**
 * Manages the dummy inputs for the Modalizer API
 */


var ModalizerAPIDummyManager = /*#__PURE__*/function (_super) {
  tslib.__extends(ModalizerAPIDummyManager, _super);

  function ModalizerAPIDummyManager(modalizerAPI, tabster, element) {
    var _this = _super.call(this, tabster, element) || this;

    _this._onFocusDummyInput = function (dummyInput) {
      var activeModalizer = _this._modalizerAPI.activeModalizer;

      if (!activeModalizer) {
        return;
      }

      if (dummyInput.shouldMoveOut) {
        return;
      }

      var findFn = dummyInput.isFirst ? 'findFirst' : 'findLast';

      var next = _this._tabster.focusable[findFn]({
        container: activeModalizer.getElement()
      });

      if (next) {
        _this._tabster.focusedElement.focus(next);
      }
    };

    _this.setTabbable = function (tabbable) {
      var tabIndex = tabbable ? 0 : -1;

      if (_this.firstDummy.input) {
        _this.firstDummy.input.tabIndex = tabIndex;
      }

      if (_this.lastDummy.input) {
        _this.lastDummy.input.tabIndex = tabIndex;
      }
    };

    _this._modalizerAPI = modalizerAPI;
    _this._tabster = tabster;
    _this.firstDummy.onFocusIn = _this._onFocusDummyInput;
    _this.lastDummy.onFocusIn = _this._onFocusDummyInput;

    _this.setTabbable(false);

    return _this;
  }

  return ModalizerAPIDummyManager;
}(DummyInputManager);

var ModalizerAPI = /*#__PURE__*/function () {
  function ModalizerAPI(tabster) {
    var _this = this;

    this._init = function () {
      _this._initTimer = undefined;

      _this._tabster.focusedElement.subscribe(_this._onFocus);
    };

    this._onModalizerDispose = function (modalizer) {
      modalizer.setActive(false);

      if (_this.activeModalizer === modalizer) {
        _this.activeModalizer = undefined;
      }

      delete _this._modalizers[modalizer.userId];
    };
    /**
     * Subscribes to the focus state and handles modalizer related focus events
     * @param e - Element that is focused
     * @param details - Additional data about the focus event
     */


    this._onFocus = function (focusedElement, details) {
      var _a, _b, _c;

      var ctx = focusedElement && RootAPI.getTabsterContext(_this._tabster, focusedElement); // Modalizer behaviour is opt in, only apply to elements that have a tabster context

      if (!ctx || !focusedElement) {
        return;
      }

      if (_this._focusOutTimer) {
        _this._win().clearTimeout(_this._focusOutTimer);

        _this._focusOutTimer = undefined;
      }

      var modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;

      if (modalizer === _this.activeModalizer) {
        return;
      } // Developers calling `element.focus()` should change/deactivate active modalizer


      if (details.isFocusedProgrammatically && !((_a = _this.activeModalizer) === null || _a === void 0 ? void 0 : _a.contains(focusedElement))) {
        (_b = _this.activeModalizer) === null || _b === void 0 ? void 0 : _b.setActive(false);
        _this.activeModalizer = undefined;

        if (modalizer) {
          _this.activeModalizer = modalizer;

          _this.activeModalizer.setActive(true);
        }
      } else if (!((_c = _this.activeModalizer) === null || _c === void 0 ? void 0 : _c.getProps().isOthersAccessible)) {
        // Focused outside of the active modalizer, try pull focus back to current modalizer
        var win = _this._win();

        win.clearTimeout(_this._restoreModalizerFocusTimer); // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration
        // Figure out a better way of doing this rather than a 100ms timeout

        _this._restoreModalizerFocusTimer = win.setTimeout(function () {
          return _this._restoreModalizerFocus(focusedElement);
        }, 100);
      }
    };

    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._initTimer = this._win().setTimeout(this._init, 0);
    this._modalizers = {};

    var documentBody = this._win().document.body;

    if (!tabster.controlTab) {
      this._dummyManager = new ModalizerAPIDummyManager(this, tabster, new WeakHTMLElement(this._win, documentBody));
    }
  }

  ModalizerAPI.prototype.dispose = function () {
    var _this = this;

    var _a;

    var win = this._win();

    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();

    if (this._initTimer) {
      win.clearTimeout(this._initTimer);
      this._initTimer = undefined;
    }

    win.clearTimeout(this._restoreModalizerFocusTimer);
    win.clearTimeout(this._focusOutTimer); // Dispose all modalizers managed by the API

    Object.keys(this._modalizers).forEach(function (modalizerId) {
      if (_this._modalizers[modalizerId]) {
        _this._modalizers[modalizerId].dispose();

        delete _this._modalizers[modalizerId];
      }
    });

    this._tabster.focusedElement.unsubscribe(this._onFocus);

    delete this.activeModalizer;
  };

  ModalizerAPI.dispose = function (instance) {
    instance.dispose();
  };

  ModalizerAPI.prototype.focus = function (elementFromModalizer, noFocusFirst, noFocusDefault) {
    var ctx = RootAPI.getTabsterContext(this._tabster, elementFromModalizer);

    if (ctx && ctx.modalizer) {
      this.activeModalizer = ctx.modalizer;
      this.activeModalizer.setActive(true);
      var props = this.activeModalizer.getProps();
      var modalizerRoot = this.activeModalizer.getElement();

      if (modalizerRoot) {
        if (noFocusFirst === undefined) {
          noFocusFirst = props.isNoFocusFirst;
        }

        if (!noFocusFirst && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() && this._tabster.focusedElement.focusFirst({
          container: modalizerRoot
        })) {
          return true;
        }

        if (noFocusDefault === undefined) {
          noFocusDefault = props.isNoFocusDefault;
        }

        if (!noFocusDefault && this._tabster.focusedElement.focusDefault(modalizerRoot)) {
          return true;
        }

        this._tabster.focusedElement.resetFocus(modalizerRoot);
      }
    } else {
      console.error('Element is not in Modalizer.', elementFromModalizer);
    }

    return false;
  };

  ModalizerAPI.updateModalizer = function (tabster, modalizer, removed) {
    if (removed && tabster.modalizer) {
      var self_1 = tabster.modalizer;

      if (modalizer.isActive()) {
        modalizer.setActive(false);
      }

      delete self_1._modalizers[modalizer.userId];

      if (self_1.activeModalizer === modalizer) {
        self_1.activeModalizer = undefined;
      }
    }
  };
  /**
   * Called when an element is focused outside of an active modalizer.
   * Attempts to pull focus back into the active modalizer
   * @param outsideElement - An element being focused outside of the modalizer
   */


  ModalizerAPI.prototype._restoreModalizerFocus = function (outsideElement) {
    if (!(outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument) || !this.activeModalizer) {
      return;
    }

    var toFocus = this._tabster.focusable.findFirst({
      container: this.activeModalizer.getElement()
    });

    if (toFocus) {
      if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {
        toFocus = this._tabster.focusable.findLast({
          container: outsideElement.ownerDocument.body
        });

        if (!toFocus) {
          // This only might mean that findFirst/findLast are buggy and inconsistent.
          throw new Error('Something went wrong.');
        }
      }

      this._tabster.focusedElement.focus(toFocus);
    } else {
      // Current Modalizer doesn't seem to have focusable elements.
      // Blurring the currently focused element which is outside of the current Modalizer.
      outsideElement.blur();
    }
  };

  ModalizerAPI.createModalizer = function (tabster, element, props) {
    var _a, _b, _c, _d, _e;

    var self = tabster.modalizer;
    var modalizer = new Modalizer(tabster, element, self._onModalizerDispose, (_b = (_a = self._dummyManager) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction) !== null && _b !== void 0 ? _b : function () {
      return null;
    }, (_d = (_c = self._dummyManager) === null || _c === void 0 ? void 0 : _c.setTabbable) !== null && _d !== void 0 ? _d : function () {
      return null;
    }, props);
    self._modalizers[props.id] = modalizer; // Adding a modalizer which is already focused, activate it

    if (element.contains((_e = tabster.focusedElement.getFocusedElement()) !== null && _e !== void 0 ? _e : null)) {
      var prevModalizer = self.activeModalizer;

      if (prevModalizer) {
        prevModalizer.setActive(false);
      }

      self.activeModalizer = modalizer;
      self.activeModalizer.setActive(true);
    }

    return modalizer;
  };

  return ModalizerAPI;
}();

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

var _inputSelector = /*#__PURE__*/['input', 'textarea', '*[contenteditable]'].join(', ');

var _isVisibleTimeout = 200;

var MoverDummyManager = /*#__PURE__*/function (_super) {
  tslib.__extends(MoverDummyManager, _super);

  function MoverDummyManager(element, tabster, getMemorized) {
    var _this = _super.call(this, tabster, element) || this;

    _this._onFocusDummyInput = function (dummyInput) {
      var _a;

      var container = _this._element.get();

      if (container && !dummyInput.shouldMoveOut) {
        var toFocus = dummyInput.isFirst ? _this._tabster.focusable.findFirst({
          container: container
        }) : _this._tabster.focusable.findLast({
          container: container
        });
        var memorized = (_a = _this._getMemorized()) === null || _a === void 0 ? void 0 : _a.get();

        if (memorized) {
          toFocus = memorized;
        }

        if (toFocus) {
          keyborg.nativeFocus(toFocus);
        }
      }
    };

    _this._tabster = tabster;
    _this._getMemorized = getMemorized;
    _this.firstDummy.onFocusIn = _this._onFocusDummyInput;
    _this.lastDummy.onFocusIn = _this._onFocusDummyInput;
    return _this;
  }

  return MoverDummyManager;
}(DummyInputManager);

var Mover = /*#__PURE__*/function (_super) {
  tslib.__extends(Mover, _super);

  function Mover(tabster, element, onDispose, props) {
    var _this = _super.call(this, tabster, element, props) || this;

    _this._visible = {};
    _this._prevVisible = {};
    _this._hasFullyVisible = false;
    _this._focusables = {};

    _this._domChanged = function () {
      var _a;

      _this._domChangedTimer = undefined;

      var element = _this.getElement();

      if (element) {
        var elements = _this._tabster.focusable.findAll({
          container: element
        });

        var newFocusables = {};
        var prevFocusables = _this._focusables;

        for (var i = 0; i < elements.length; i++) {
          var el = elements[i];
          var id = getElementUId(_this._win, el);
          var weakEl = prevFocusables[id];

          if (!weakEl) {
            weakEl = new WeakHTMLElement(_this._win, el);
          }

          newFocusables[id] = weakEl;
        }

        for (var _i = 0, _b = Object.keys(prevFocusables); _i < _b.length; _i++) {
          var id = _b[_i];

          if (!(id in newFocusables)) {
            var prevFocusable = prevFocusables[id].get();
            delete prevFocusables[id];
            delete _this._visible[id];

            if (prevFocusable && ((_a = _this._current) === null || _a === void 0 ? void 0 : _a.get()) === prevFocusable) {
              _this.setCurrent(undefined);
            }
          }
        }

        _this._focusables = newFocusables;

        _this.updateVisible(true);
      }
    };

    _this._win = tabster.getWindow;

    if (_this._props.trackState || _this._props.visibilityAware) {
      _this._observeState();

      _this._domChangedTimer = tabster.getWindow().setTimeout(_this._domChanged, 0);
    }

    _this._onDispose = onDispose;

    var getMemorized = function getMemorized() {
      return props.memorizeCurrent ? _this._current : undefined;
    };

    if (!tabster.controlTab) {
      _this._dummyManagner = new MoverDummyManager(_this._element, tabster, getMemorized);
    }

    return _this;
  }

  Mover.prototype.dispose = function () {
    var _a;

    this._onDispose(this);

    this._focusables = {};

    if (this._unobserve) {
      this._unobserve();

      this._unobserve = undefined;
    }

    var win = this._win();

    if (this._updateVisibleTimer) {
      win.clearTimeout(this._updateVisibleTimer);
      this._updateVisibleTimer = undefined;
    }

    if (this._domChangedTimer) {
      win.clearTimeout(this._domChangedTimer);
      this._domChangedTimer = undefined;
    }

    if (this._onChangeTimer) {
      win.clearTimeout(this._onChangeTimer);
      this._onChangeTimer = undefined;
    }

    (_a = this._dummyManagner) === null || _a === void 0 ? void 0 : _a.dispose();
  };

  Mover.prototype.setCurrent = function (element) {
    if (element) {
      this._current = new WeakHTMLElement(this._win, element);
    } else {
      this._current = undefined;
    }

    if (this._props.trackState || this._props.visibilityAware) {
      this._processOnChange();
    }

    return false;
  };

  Mover.prototype.getCurrent = function () {
    var _a;

    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;
  };

  Mover.prototype.findNextTabbable = function (current, prev) {
    var container = this.getElement();

    if (!container || !container.contains(current)) {
      return null;
    }

    var tabster = this._tabster;
    var focusable = tabster.focusable;
    var next = null;
    var uncontrolled;

    var onUncontrolled = function onUncontrolled(el) {
      uncontrolled = el;
    };

    if (this._props.tabbable) {
      next = prev ? focusable.findPrev({
        currentElement: current,
        container: container,
        onUncontrolled: onUncontrolled
      }) : focusable.findNext({
        currentElement: current,
        container: container,
        onUncontrolled: onUncontrolled
      });
    }

    if (next === null) {
      var parentElement = container.parentElement;

      if (parentElement) {
        var parentCtx = RootAPI.getTabsterContext(tabster, parentElement);

        if (parentCtx) {
          var from = (prev ? container : focusable.findLast({
            container: container
          })) || container;
          return FocusedElementState.findNextTabbable(tabster, parentCtx, from, prev);
        }
      }
    }

    return {
      element: next,
      uncontrolled: uncontrolled
    };
  };

  Mover.prototype.acceptElement = function (element, state) {
    var _a, _b;

    var _c = this._props,
        memorizeCurrent = _c.memorizeCurrent,
        visibilityAware = _c.visibilityAware;

    if (memorizeCurrent || visibilityAware) {
      var container = this.getElement();

      if (container) {
        if (memorizeCurrent) {
          var current = (_a = this._current) === null || _a === void 0 ? void 0 : _a.get();

          if (current && state.acceptCondition(current)) {
            if (state.from && !container.contains(state.from)) {
              state.found = true;
              state.foundElement = current;
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        }

        if (visibilityAware && !container.contains(state.from)) {
          var visible = Object.keys(this._visible);
          var found = void 0;

          if (!state.isForward) {
            visible.reverse();
          }

          for (var _i = 0, visible_1 = visible; _i < visible_1.length; _i++) {
            var id = visible_1[_i];
            var visibility = this._visible[id];

            if (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._hasFullyVisible)) {
              found = (_b = this._focusables[id]) === null || _b === void 0 ? void 0 : _b.get();

              if (found && state.acceptCondition(found)) {
                state.found = true;
                state.foundElement = found;
                return NodeFilter.FILTER_ACCEPT;
              }
            }
          }
        }
      }
    }

    return undefined;
  };

  Mover.prototype._observeState = function () {
    var _this = this;

    var element = this.getElement();

    if (this._unobserve || !element || typeof MutationObserver === 'undefined') {
      return;
    }

    var observer = new MutationObserver(function () {
      var win = _this._win();

      if (_this._domChangedTimer) {
        win.clearTimeout(_this._domChangedTimer);
      }

      _this._domChangedTimer = win.setTimeout(_this._domChanged, 0);
    });
    observer.observe(element, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ['tabindex']
    });

    this._unobserve = function () {
      observer.disconnect();
    };
  };

  Mover.prototype.forceUpdate = function () {
    this._processOnChange(true);
  };

  Mover.prototype._processOnChange = function (force) {
    var _this = this;

    if (this._onChangeTimer && !force) {
      return;
    }

    var reallyProcessOnChange = function reallyProcessOnChange() {
      _this._onChangeTimer = undefined;
      var changed = [];

      if (_this._current !== _this._prevCurrent) {
        changed.push(_this._current);
        changed.push(_this._prevCurrent);
        _this._prevCurrent = _this._current;
      }

      if (_this._visible !== _this._prevVisible) {
        _this._hasFullyVisible = false;

        for (var _i = 0, _a = Object.keys(_this._visible); _i < _a.length; _i++) {
          var id = _a[_i];
          var visibility = _this._visible[id];

          if (visibility !== _this._prevVisible[id]) {
            changed.push(_this._focusables[id]);
          }

          if (visibility === Visibilities.Visible) {
            _this._hasFullyVisible = true;
          }
        }

        for (var _b = 0, _c = Object.keys(_this._prevVisible); _b < _c.length; _b++) {
          var id = _c[_b];

          if (_this._visible[id] !== _this._prevVisible[id]) {
            changed.push(_this._focusables[id]);
          }
        }

        _this._prevVisible = _this._visible;
      }

      var processed = {};

      for (var _d = 0, changed_1 = changed; _d < changed_1.length; _d++) {
        var weak = changed_1[_d];
        var el = weak === null || weak === void 0 ? void 0 : weak.get();
        var id = el && getElementUId(_this._win, el);

        if (id && !processed[id]) {
          processed[id] = true;

          if (_this._focusables[id]) {
            var props = _this._props;

            if (el && (props.visibilityAware !== undefined || props.trackState)) {
              var state = _this.getState(el);

              if (state) {
                triggerEvent(el, MoverEventName, state);
              }
            }
          }
        }
      }
    };

    if (this._onChangeTimer) {
      this._win().clearTimeout(this._onChangeTimer);
    }

    if (force) {
      reallyProcessOnChange();
    } else {
      this._onChangeTimer = this._win().setTimeout(reallyProcessOnChange, 0);
    }
  };

  Mover.prototype.getState = function (element) {
    var id = getElementUId(this._win, element);

    if (id in this._visible) {
      var visibility = this._visible[id] || Visibilities.Invisible;
      var isCurrent = this._current ? this._current.get() === element : undefined;
      return {
        isCurrent: isCurrent,
        visibility: visibility
      };
    }

    return undefined;
  };

  Mover.prototype.updateVisible = function (updateParents) {
    var _this = this;

    var _a;

    var element = this._element.get();

    if (this._updateVisibleTimer || !element) {
      return;
    }

    if (updateParents) {
      for (var e = element.parentElement; e; e = e.parentElement) {
        var mover = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.mover;

        if (mover) {
          mover.updateVisible(false);
        }
      }
    }

    this._updateVisibleTimer = this._win().setTimeout(function () {
      _this._updateVisibleTimer = undefined;
      var isChanged = false;
      var visibleMovers = {};

      for (var _i = 0, _a = Object.keys(_this._focusables); _i < _a.length; _i++) {
        var id = _a[_i];

        var element_1 = _this._focusables[id].get();

        var visible = element_1 ? isElementVisibleInContainer(_this._win, element_1, 10) : Visibilities.Invisible;
        var curIsVisible = _this._visible[id] || Visibilities.Invisible;

        if (visible !== Visibilities.Invisible) {
          visibleMovers[id] = visible;
        }

        if (curIsVisible !== visible) {
          isChanged = true;
        }
      }

      if (isChanged) {
        _this._prevVisible = _this._visible;
        _this._visible = visibleMovers;

        _this._processOnChange();
      }
    }, 0);
  };

  return Mover;
}(TabsterPart);

var MoverAPI = /*#__PURE__*/function () {
  function MoverAPI(tabster, getWindow) {
    var _this = this;

    this._scrollTargets = [];

    this._init = function () {
      _this._initTimer = undefined;

      var win = _this._win();

      win.addEventListener('scroll', _this._onScroll, true);
      win.addEventListener('keydown', _this._onKeyDown, true);
    };

    this._onMoverDispose = function (mover) {
      delete _this._movers[mover.id];
    };

    this._onFocus = function (e) {
      var _a;

      for (var el = e; el; el = el.parentElement) {
        var mover = (_a = getTabsterOnElement(_this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;

        if (mover) {
          mover.setCurrent(e);
          break;
        }
      }
    };

    this._onScroll = function (e) {
      var isKnownTarget = false;

      for (var _i = 0, _a = _this._scrollTargets; _i < _a.length; _i++) {
        var t = _a[_i];

        if (t === e.target) {
          isKnownTarget = true;
          break;
        }
      } // Cannot simply use (e.target instanceof Node) as it might
      // originate from another window.


      if (!isKnownTarget && e.target.contains) {
        _this._scrollTargets.push(e.target);
      }

      var win = _this._win();

      if (_this._scrollTimer) {
        win.clearTimeout(_this._scrollTimer);
      }

      _this._scrollTimer = win.setTimeout(function () {
        _this._scrollTimer = undefined;

        _this._updateVisible(_this._scrollTargets);

        _this._scrollTargets = [];
      }, _isVisibleTimeout);
    };

    this._onKeyDown = function (e) {
      var _a, _b;

      var keyCode = e.keyCode;

      switch (keyCode) {
        case Keys.Down:
        case Keys.Right:
        case Keys.Up:
        case Keys.Left:
        case Keys.PageDown:
        case Keys.PageUp:
        case Keys.Home:
        case Keys.End:
        case Keys.Tab:
          break;

        default:
          return;
      }

      var tabster = _this._tabster;
      var focused = tabster.focusedElement.getFocusedElement();

      if (!focused || _this._isIgnoredInput(focused, keyCode)) {
        return;
      }

      var ctx = RootAPI.getTabsterContext(tabster, focused, {
        checkRtl: true
      });

      if (!ctx || !ctx.mover) {
        return;
      }

      if (ctx.isGroupperFirst) {
        if (ctx.groupper && ctx.groupper.isActive()) {
          return;
        }
      }

      var mover = ctx.mover;
      var container = mover.getElement();

      if (!container) {
        return;
      }

      var focusable = tabster.focusable;
      var moverProps = mover.getProps();
      var direction = moverProps.direction || MoverDirections.Both;
      var isBoth = direction === MoverDirections.Both;
      var isVertical = isBoth || direction === MoverDirections.Vertical;
      var isHorizontal = isBoth || direction === MoverDirections.Horizontal;
      var isGrid = direction === MoverDirections.Grid;
      var isCyclic = moverProps.cyclic;
      var next;

      if (moverProps.disableHomeEndKeys && (keyCode === Keys.Home || keyCode === Keys.End)) {
        return;
      }

      if (ctx.isRtl) {
        if (keyCode === Keys.Right) {
          keyCode = Keys.Left;
        } else if (keyCode === Keys.Left) {
          keyCode = Keys.Right;
        }
      }

      if (keyCode === Keys.Down && isVertical || keyCode === Keys.Right && isHorizontal) {
        next = focusable.findNext({
          currentElement: focused,
          container: container
        });

        if (!next && isCyclic) {
          next = focusable.findFirst({
            container: container
          });
        }
      } else if (keyCode === Keys.Up && isVertical || keyCode === Keys.Left && isHorizontal) {
        next = focusable.findPrev({
          currentElement: focused,
          container: container
        });

        if (!next && isCyclic) {
          next = focusable.findLast({
            container: container
          });
        }
      } else if (keyCode === Keys.Home) {
        next = focusable.findFirst({
          container: container
        });
      } else if (keyCode === Keys.End) {
        next = focusable.findLast({
          container: container
        });
      } else if (keyCode === Keys.PageUp) {
        var prevElement = focusable.findPrev({
          currentElement: focused,
          container: container
        });
        var pageUpElement = null;

        while (prevElement) {
          pageUpElement = prevElement;
          prevElement = isElementVerticallyVisibleInContainer(_this._win, prevElement) ? focusable.findPrev({
            currentElement: prevElement,
            container: container
          }) : null;
        }

        next = pageUpElement;

        if (next) {
          scrollIntoView(_this._win, next, false);
        }
      } else if (keyCode === Keys.PageDown) {
        var nextElement = focusable.findNext({
          currentElement: focused,
          container: container
        });
        var pageDownElement = null;

        while (nextElement) {
          pageDownElement = nextElement;
          nextElement = isElementVerticallyVisibleInContainer(_this._win, nextElement) ? focusable.findNext({
            currentElement: nextElement,
            container: container
          }) : null;
        }

        next = pageDownElement;

        if (next) {
          scrollIntoView(_this._win, next, true);
        }
      } else if (keyCode === Keys.Tab && !tabster.controlTab) {
        next = (_a = FocusedElementState.findNextTabbable(tabster, ctx, focused, e.shiftKey)) === null || _a === void 0 ? void 0 : _a.element;
      } else if (isGrid) {
        var fromRect = focused.getBoundingClientRect();
        var lastElement = void 0;
        var prevTop = void 0;
        var nextMethod = keyCode === Keys.Down || keyCode === Keys.Right ? 'findNext' : 'findPrev';

        for (var el = focusable[nextMethod]({
          currentElement: focused,
          container: container
        }); el; el = focusable[nextMethod]({
          currentElement: el,
          container: container
        })) {
          var rect = el.getBoundingClientRect();

          if (keyCode === Keys.Up) {
            if (rect.top < fromRect.top) {
              if (prevTop === undefined) {
                prevTop = rect.top;
              } else if (rect.top < prevTop) {
                break;
              }

              if (rect.left < fromRect.left) {
                if (!next) {
                  next = el;
                }

                break;
              }

              next = el;
            }
          } else if (keyCode === Keys.Down) {
            if (rect.top > fromRect.top) {
              if (prevTop === undefined) {
                prevTop = rect.top;
              } else if (rect.top > prevTop) {
                break;
              }

              if (rect.left > fromRect.left) {
                if (!next) {
                  next = el;
                }

                break;
              }

              next = el;
            }
          } else if (keyCode === Keys.Left || keyCode === Keys.Right) {
            next = el;
            break;
          }

          lastElement = el;
        }

        if (!next) {
          next = lastElement;
        }
      }

      if (next) {
        e.preventDefault();
        e.stopImmediatePropagation();
        keyborg.nativeFocus(next);
      } else {
        if (keyCode === Keys.Tab) {
          (_b = mover._dummyManagner) === null || _b === void 0 ? void 0 : _b.moveOutWithDefaultAction(e.shiftKey);
        }
      }
    };

    this._tabster = tabster;
    this._win = getWindow;
    this._initTimer = getWindow().setTimeout(this._init, 0);
    this._movers = {};
    tabster.focusedElement.subscribe(this._onFocus);
  }

  MoverAPI.prototype.dispose = function () {
    var _this = this;

    var win = this._win();

    this._tabster.focusedElement.unsubscribe(this._onFocus);

    if (this._initTimer) {
      win.clearTimeout(this._initTimer);
      this._initTimer = undefined;
    }

    if (this._scrollTimer) {
      win.clearTimeout(this._scrollTimer);
      this._scrollTimer = undefined;
    }

    win.removeEventListener('scroll', this._onScroll, true);
    this._scrollTargets = [];
    win.removeEventListener('keydown', this._onKeyDown, true);
    Object.keys(this._movers).forEach(function (moverId) {
      if (_this._movers[moverId]) {
        _this._movers[moverId].dispose();

        delete _this._movers[moverId];
      }
    });
  };

  MoverAPI.dispose = function (instance) {
    instance.dispose();
  };

  MoverAPI.prototype._updateVisible = function (scrolled) {
    var containers = {};

    for (var _i = 0, scrolled_1 = scrolled; _i < scrolled_1.length; _i++) {
      var s = scrolled_1[_i];

      for (var _a = 0, _b = Object.keys(this._movers); _a < _b.length; _a++) {
        var id = _b[_a];
        var container = this._movers[id];
        var containerElement = container.getElement();

        if (containerElement && s.contains(containerElement)) {
          containers[container.id] = container;
        }
      }
    }

    for (var _c = 0, _d = Object.keys(containers); _c < _d.length; _c++) {
      var id = _d[_c];
      containers[id].updateVisible(false);
    }
  };

  MoverAPI.prototype._isIgnoredInput = function (element, keyCode) {
    if (matchesSelector(element, _inputSelector)) {
      if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {
        var selectionStart = element.selectionStart || 0;
        var selectionEnd = element.selectionEnd || 0;

        if (selectionStart !== selectionEnd) {
          return true;
        }

        if (selectionStart > 0 && (keyCode === Keys.Left || keyCode === Keys.Up || keyCode === Keys.Home)) {
          return true;
        }

        if (selectionStart < (element.value || '').length && (keyCode === Keys.Right || keyCode === Keys.Down || keyCode === Keys.End)) {
          return true;
        }
      }
    }

    return false;
  };

  MoverAPI.createMover = function (tabster, element, props) {

    var self = tabster.mover;
    var newMover = new Mover(tabster, element, self._onMoverDispose, props);
    self._movers[newMover.id] = newMover;
    return newMover;
  };

  return MoverAPI;
}();

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function observeMutations(doc, tabster, updateTabsterByAttribute, syncState) {
  if (typeof MutationObserver === 'undefined') {
    return function () {};
  }

  var getWindow = tabster.getWindow;
  var elementByUId;

  var onMutation = function onMutation(mutations) {
    for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
      var mutation = mutations_1[_i];
      var target = mutation.target;
      var removed = mutation.removedNodes;
      var added = mutation.addedNodes;

      if (mutation.type === 'attributes') {
        if (mutation.attributeName === TabsterAttributeName) {
          updateTabsterByAttribute(tabster, target);
        }
      } else {
        for (var i = 0; i < removed.length; i++) {
          updateTabsterElements(removed[i], true);
        }

        for (var i = 0; i < added.length; i++) {
          updateTabsterElements(added[i]);
        }
      }
    }
  };

  function updateTabsterElements(node, removed) {
    if (!elementByUId) {
      elementByUId = getInstanceContext(getWindow).elementByUId;
    }

    processNode(node, removed);
    var walker = createElementTreeWalker(doc, node, function (element) {
      return processNode(element, removed);
    });

    if (walker) {
      while (walker.nextNode()) {
        /* Iterating for the sake of calling processNode() callback. */
      }
    }
  }

  function processNode(element, removed) {
    var _a;

    var _b;

    if (!element.getAttribute) {
      // It might actually be a text node.
      return NodeFilter.FILTER_SKIP;
    }

    var uid = element.__tabsterElementUID;

    if (uid) {
      if (removed) {
        delete elementByUId[uid];
      } else {
        (_a = (_b = elementByUId)[uid]) !== null && _a !== void 0 ? _a : _b[uid] = new WeakHTMLElement(getWindow, element);
      }
    }

    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TabsterAttributeName)) {
      updateTabsterByAttribute(tabster, element, removed);
    }

    return NodeFilter.FILTER_SKIP;
  }

  var observer = new MutationObserver(onMutation);

  if (syncState) {
    updateTabsterElements(getWindow().document.body);
  }

  observer.observe(doc, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: [TabsterAttributeName]
  });
  return function () {
    observer.disconnect();
  };
}

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var _conditionCheckTimeout = 100;

var ObservedElementAPI = /*#__PURE__*/function (_super) {
  tslib.__extends(ObservedElementAPI, _super);

  function ObservedElementAPI(tabster) {
    var _this = _super.call(this) || this;

    _this._waiting = {};
    _this._lastRequestFocusId = 0;
    _this._observedById = {};
    _this._observedByName = {};
    _this._currentRequestTimestamp = 0;

    _this._init = function () {
      _this._initTimer = undefined;

      _this._tabster.focusedElement.subscribe(_this._onFocus);
    };

    _this._onFocus = function (e) {
      if (e) {
        var current = _this._currentRequest;

        if (current) {
          var delta = Date.now() - _this._currentRequestTimestamp;

          var settleTime = 300;

          if (delta >= settleTime) {
            // Giving some time for the focus to settle before
            // automatically cancelling the current request on focus change.
            delete _this._currentRequest;
            current.cancel();
          }
        }
      }
    };

    _this.onObservedElementUpdate = function (element) {
      var _a;

      var observed = (_a = getTabsterOnElement(_this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;
      var uid = getElementUId(_this._win, element);
      var info = _this._observedById[uid];

      if (observed && documentContains(element.ownerDocument, element)) {
        if (!info) {
          info = _this._observedById[uid] = {
            element: new WeakHTMLElement(_this._win, element)
          };
        }

        var observedName = observed.name;
        var prevName = info.prevName;

        if (observedName !== prevName) {
          if (prevName) {
            var obn_1 = _this._observedByName[prevName];

            if (obn_1 && obn_1[uid]) {
              if (Object.keys(obn_1).length > 1) {
                delete obn_1[uid];
              } else {
                delete _this._observedByName[prevName];
              }
            }
          }

          info.prevName = observedName;
        }

        var obn = _this._observedByName[observedName];

        if (!obn) {
          obn = _this._observedByName[observedName] = {};
        }

        obn[uid] = info;

        _this._waitConditional(observedName);
      } else if (info) {
        var prevName = info.prevName;

        if (prevName) {
          var obn = _this._observedByName[prevName];

          if (obn && obn[uid]) {
            if (Object.keys(obn).length > 1) {
              delete obn[uid];
            } else {
              delete _this._observedByName[prevName];
            }
          }
        }

        delete _this._observedById[uid];
      }
    };

    _this._tabster = tabster;
    _this._win = tabster.getWindow;
    _this._initTimer = _this._win().setTimeout(_this._init, 0);
    return _this;
  }

  ObservedElementAPI.prototype.dispose = function () {
    var win = this._win();

    if (this._initTimer) {
      win.clearTimeout(this._initTimer);
      this._initTimer = undefined;
    }

    this._tabster.focusedElement.unsubscribe(this._onFocus);

    for (var _i = 0, _a = Object.keys(this._waiting); _i < _a.length; _i++) {
      var key = _a[_i];

      this._rejectWaiting(key);
    }

    this._observedById = {};
    this._observedByName = {};
  };

  ObservedElementAPI.prototype._rejectWaiting = function (key, shouldResolve) {
    var w = this._waiting[key];

    if (w) {
      var win = this._win();

      if (w.timer) {
        win.clearTimeout(w.timer);
      }

      if (w.conditionTimer) {
        win.clearTimeout(w.conditionTimer);
      }

      if (!shouldResolve && w.reject) {
        w.reject();
      } else if (shouldResolve && w.resolve) {
        w.resolve(null);
      }

      delete this._waiting[key];
    }
  };

  ObservedElementAPI.dispose = function (instance) {
    instance.dispose();
  };
  /**
   * Returns existing element by observed name
   *
   * @param observedName An observed name
   * @param accessibility Optionally, return only if the element is accessible or focusable
   * @returns HTMLElement | null
   */


  ObservedElementAPI.prototype.getElement = function (observedName, accessibility) {
    var o = this._observedByName[observedName];

    if (o) {
      for (var _i = 0, _a = Object.keys(o); _i < _a.length; _i++) {
        var uid = _a[_i];
        var el = o[uid].element.get() || null;

        if (el) {
          if (accessibility === ObservedElementAccesibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccesibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {
            el = null;
          }
        } else {
          delete o[uid];
          delete this._observedById[uid];
        }

        return el;
      }
    }

    return null;
  };
  /**
   * Waits for the element to appear in the DOM and returns it.
   *
   * @param observedName An observed name
   * @param timeout Wait no longer than this timeout
   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it
   * @returns Promise<HTMLElement | null>
   */


  ObservedElementAPI.prototype.waitElement = function (observedName, timeout, accessibility) {
    var _this = this;

    var el = this.getElement(observedName, accessibility);

    if (el) {
      return {
        result: getPromise(this._win).resolve(el),
        cancel: function cancel() {}
      };
    }

    var prefix;

    if (accessibility === ObservedElementAccesibilities.Accessible) {
      prefix = 'a';
    } else if (accessibility === ObservedElementAccesibilities.Focusable) {
      prefix = 'f';
    } else {
      prefix = '_';
    }

    var key = prefix + observedName;
    var w = this._waiting[key];

    if (w && w.request) {
      return w.request;
    }

    w = this._waiting[key] = {
      timer: this._win().setTimeout(function () {
        if (w.conditionTimer) {
          _this._win().clearTimeout(w.conditionTimer);
        }

        delete _this._waiting[key];

        if (w.resolve) {
          w.resolve(null);
        }
      }, timeout)
    };
    var promise = new (getPromise(this._win))(function (resolve, reject) {
      w.resolve = resolve;
      w.reject = reject;
    });
    w.request = {
      result: promise,
      cancel: function cancel() {
        _this._rejectWaiting(key, true);
      }
    };

    if (accessibility && this.getElement(observedName)) {
      // If the observed element is alread in DOM, but not accessible yet,
      // we need to run the wait logic.
      this._waitConditional(observedName);
    }

    return w.request;
  };

  ObservedElementAPI.prototype.requestFocus = function (observedName, timeout) {
    var _this = this;

    var requestId = ++this._lastRequestFocusId;
    var currentRequestFocus = this._currentRequest;

    if (currentRequestFocus) {
      currentRequestFocus.cancel();
    }

    var request = this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable);
    this._currentRequest = request;
    this._currentRequestTimestamp = Date.now();
    request.result["finally"](function () {
      if (_this._currentRequest === request) {
        delete _this._currentRequest;
      }
    });
    return {
      result: request.result.then(function (element) {
        return _this._lastRequestFocusId === requestId && element ? _this._tabster.focusedElement.focus(element, true) : false;
      }),
      cancel: function cancel() {
        request.cancel();
      }
    };
  };

  ObservedElementAPI.prototype._waitConditional = function (observedName) {
    var _this = this;

    var waitingElementKey = '_' + observedName;
    var waitingAccessibleElementKey = 'a' + observedName;
    var waitingFocusableElementKey = 'f' + observedName;
    var waitingElement = this._waiting[waitingElementKey];
    var waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];
    var waitingFocusableElement = this._waiting[waitingFocusableElementKey];

    var win = this._win();

    var resolve = function resolve(element, key, waiting, accessibility) {
      var _a;

      var observed = (_a = getTabsterOnElement(_this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;

      if (!observed || observed.name !== observedName) {
        return;
      }

      if (waiting.timer) {
        win.clearTimeout(waiting.timer);
      }

      delete _this._waiting[key];

      if (waiting.resolve) {
        waiting.resolve(element);
      }

      _this.trigger(element, {
        name: observedName,
        details: observed.details,
        accessibility: accessibility
      });
    };

    if (waitingElement) {
      var element = this.getElement(observedName);

      if (element && documentContains(element.ownerDocument, element)) {
        resolve(element, waitingElementKey, waitingElement, ObservedElementAccesibilities.Any);
      }
    }

    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {
      var resolveAccessible_1 = function resolveAccessible_1() {
        var element = _this.getElement(observedName);

        if (element && documentContains(element.ownerDocument, element) && _this._tabster.focusable.isAccessible(element)) {
          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccesibilities.Accessible);
        } else {
          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible_1, _conditionCheckTimeout);
        }
      };

      resolveAccessible_1();
    }

    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {
      var resolveFocusable_1 = function resolveFocusable_1() {
        var element = _this.getElement(observedName);

        if (element && documentContains(element.ownerDocument, element) && _this._tabster.focusable.isFocusable(element, true)) {
          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccesibilities.Focusable);
        } else {
          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable_1, _conditionCheckTimeout);
        }
      };

      resolveFocusable_1();
    }
  };

  return ObservedElementAPI;
}(Subscribable);

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var defaultProps = {
  areaClass: 'tabster-focus-outline-area',
  outlineClass: 'tabster-focus-outline',
  outlineColor: '#ff4500',
  outlineWidth: 2,
  zIndex: 2147483647
};
var _props = defaultProps;

var _fullScreenEventName;

var _fullScreenElementName;

if (typeof document !== 'undefined') {
  if ('onfullscreenchange' in document) {
    _fullScreenEventName = 'fullscreenchange';
    _fullScreenElementName = 'fullscreenElement';
  } else if ('onwebkitfullscreenchange' in document) {
    _fullScreenEventName = 'webkitfullscreenchange';
    _fullScreenElementName = 'webkitFullscreenElement';
  } else if ('onmozfullscreenchange' in document) {
    _fullScreenEventName = 'mozfullscreenchange';
    _fullScreenElementName = 'mozFullScreenElement';
  } else if ('onmsfullscreenchange' in document) {
    _fullScreenEventName = 'msfullscreenchange';
    _fullScreenElementName = 'msFullscreenElement';
  }
}

var OutlinePosition = /*#__PURE__*/function () {
  function OutlinePosition(left, top, right, bottom) {
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }

  OutlinePosition.prototype.equalsTo = function (other) {
    return this.left === other.left && this.top === other.top && this.right === other.right && this.bottom === other.bottom;
  };

  OutlinePosition.prototype.clone = function () {
    return new OutlinePosition(this.left, this.top, this.right, this.bottom);
  };

  return OutlinePosition;
}();

var OutlineAPI = /*#__PURE__*/function () {
  function OutlineAPI(tabster) {
    var _this = this;

    this._isVisible = false;
    this._allOutlineElements = [];

    this._init = function () {
      _this._initTimer = undefined;

      _this._tabster.keyboardNavigation.subscribe(_this._onKeyboardNavigationStateChanged);

      _this._tabster.focusedElement.subscribe(_this._onFocus);

      var win = _this._win();

      win.addEventListener('scroll', _this._onScroll, true); // Capture!

      if (_fullScreenEventName) {
        win.document.addEventListener(_fullScreenEventName, _this._onFullScreenChanged);
      }
    };

    this._onFullScreenChanged = function (e) {
      if (!_fullScreenElementName || !e.target) {
        return;
      }

      var target = e.target.body || e.target;

      var outlineElements = _this._getDOM(target);

      if (target.ownerDocument && outlineElements) {
        var fsElement = target.ownerDocument[_fullScreenElementName];

        if (fsElement) {
          fsElement.appendChild(outlineElements.container);
          _this._fullScreenElement = fsElement;
        } else {
          target.ownerDocument.body.appendChild(outlineElements.container);
          _this._fullScreenElement = undefined;
        }
      }
    };

    this._onKeyboardNavigationStateChanged = function () {
      _this._onFocus(_this._tabster.focusedElement.getFocusedElement());
    };

    this._onFocus = function (e) {
      if (!_this._updateElement(e) && _this._isVisible) {
        _this._setVisibility(false);
      }
    };

    this._onScroll = function (e) {
      if (!_this._outlinedElement || !OutlineAPI._isParentChild(e.target, _this._outlinedElement)) {
        return;
      }

      _this._curPos = undefined;

      _this._setOutlinePosition();
    };

    this._tabster = tabster;
    this._win = tabster.getWindow;
    this._initTimer = this._win().setTimeout(this._init, 0);
  }

  OutlineAPI.prototype.setup = function (props) {
    _props = tslib.__assign(tslib.__assign({}, _props), props);

    var win = this._win();

    if (!win.__tabsterOutline) {
      win.__tabsterOutline = {};
    }

    if (!win.__tabsterOutline.style) {
      win.__tabsterOutline.style = appendStyles(win.document, _props);
    }

    if (!props || !props.areaClass) {
      win.document.body.classList.add(defaultProps.areaClass);
    } else {
      win.document.body.classList.remove(defaultProps.areaClass);
    }
  };

  OutlineAPI.prototype.dispose = function () {
    var _this = this;

    var win = this._win();

    if (this._initTimer) {
      win.clearTimeout(this._initTimer);
      this._initTimer = undefined;
    }

    if (this._updateTimer) {
      win.clearTimeout(this._updateTimer);
      this._updateTimer = undefined;
    }

    this._tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);

    this._tabster.focusedElement.unsubscribe(this._onFocus);

    win.removeEventListener('scroll', this._onScroll, true);

    if (_fullScreenEventName) {
      win.document.removeEventListener(_fullScreenEventName, this._onFullScreenChanged);
    }

    this._allOutlineElements.forEach(function (outlineElements) {
      return _this._removeDOM(outlineElements.container);
    });

    this._allOutlineElements = [];
    delete this._outlinedElement;
    delete this._curPos;
    delete this._curOutlineElements;
    delete this._fullScreenElement;
  };

  OutlineAPI.dispose = function (instance) {
    instance.dispose();
  };

  OutlineAPI.prototype._shouldShowCustomOutline = function (element) {
    var tabsterOnElement = getTabsterOnElement(this._tabster, element);

    if (tabsterOnElement && tabsterOnElement.outline && tabsterOnElement.outline.isIgnored) {
      return false;
    }

    for (var i = element; i; i = i.parentElement) {
      if (i.classList && i.classList.contains(_props.areaClass)) {
        return true;
      }
    }

    return false;
  };

  OutlineAPI.prototype._updateElement = function (e) {
    this._outlinedElement = undefined;

    if (this._updateTimer) {
      this._win().clearTimeout(this._updateTimer);

      this._updateTimer = undefined;
    }

    this._curPos = undefined;

    if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {
      return false;
    }

    if (e) {
      // TODO: It's hard (and not necessary) to come up with every possible
      // condition when there should be no outline, it's better to add an
      // API to customize the ignores.
      if (e.tagName === 'INPUT') {
        var inputType = e.type;
        var outlinedInputTypes = {
          button: true,
          checkbox: true,
          file: true,
          image: true,
          radio: true,
          range: true,
          reset: true,
          submit: true
        };

        if (!(inputType in outlinedInputTypes)) {
          return false;
        }
      } else if (e.tagName === 'TEXTAREA' || e.contentEditable === 'true' || e.tagName === 'IFRAME') {
        return false;
      }

      if (!this._shouldShowCustomOutline(e)) {
        return false;
      }

      if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {
        this._outlinedElement = e;

        this._updateOutline();
      }

      return true;
    }

    return false;
  };

  OutlineAPI.prototype._updateOutline = function () {
    var _this = this;

    this._setOutlinePosition();

    if (this._updateTimer) {
      this._win().clearTimeout(this._updateTimer);

      this._updateTimer = undefined;
    }

    if (!this._outlinedElement) {
      return;
    }

    this._updateTimer = this._win().setTimeout(function () {
      _this._updateTimer = undefined;

      _this._updateOutline();
    }, 30);
  };

  OutlineAPI.prototype._setVisibility = function (visible) {
    this._isVisible = visible;

    if (this._curOutlineElements) {
      if (visible) {
        this._curOutlineElements.container.classList.add(_props.outlineClass + "_visible");
      } else {
        this._curOutlineElements.container.classList.remove(_props.outlineClass + "_visible");

        this._curPos = undefined;
      }
    }
  };

  OutlineAPI.prototype._setOutlinePosition = function () {
    if (!this._outlinedElement) {
      return;
    }

    var boundingRect = getBoundingRect(this._win, this._outlinedElement);
    var position = new OutlinePosition(boundingRect.left, boundingRect.top, boundingRect.right, boundingRect.bottom);

    if (this._curPos && position.equalsTo(this._curPos)) {
      return;
    }

    var outlineElements = this._getDOM(this._outlinedElement);

    var win = this._outlinedElement.ownerDocument && this._outlinedElement.ownerDocument.defaultView;

    if (!outlineElements || !win) {
      return;
    }

    if (this._curOutlineElements !== outlineElements) {
      this._setVisibility(false);

      this._curOutlineElements = outlineElements;
    }

    this._curPos = position;
    var p = position.clone();
    var hasAbsolutePositionedParent = false;
    var hasFixedPositionedParent = false;
    var container = outlineElements.container;
    var scrollingElement = container && container.ownerDocument && container.ownerDocument.scrollingElement;

    if (!scrollingElement) {
      return;
    }

    for (var parent_1 = this._outlinedElement.parentElement; parent_1; parent_1 = parent_1.parentElement) {
      // The element might be partially visible within its scrollable parent,
      // reduce the bounding rect if this is the case.
      if (parent_1 === this._fullScreenElement) {
        break;
      }

      boundingRect = getBoundingRect(this._win, parent_1);
      var win_1 = parent_1.ownerDocument && parent_1.ownerDocument.defaultView;

      if (!win_1) {
        return;
      }

      var computedStyle = win_1.getComputedStyle(parent_1);
      var position_1 = computedStyle.position;

      if (position_1 === 'absolute') {
        hasAbsolutePositionedParent = true;
      } else if (position_1 === 'fixed' || position_1 === 'sticky') {
        hasFixedPositionedParent = true;
      }

      if (computedStyle.overflow === 'visible') {
        continue;
      }

      if (!hasAbsolutePositionedParent && !hasFixedPositionedParent || computedStyle.overflow === 'hidden') {
        if (boundingRect.left > p.left) {
          p.left = boundingRect.left;
        }

        if (boundingRect.top > p.top) {
          p.top = boundingRect.top;
        }

        if (boundingRect.right < p.right) {
          p.right = boundingRect.right;
        }

        if (boundingRect.bottom < p.bottom) {
          p.bottom = boundingRect.bottom;
        }
      }
    }

    var allRect = getBoundingRect(this._win, scrollingElement);
    var allWidth = allRect.left + allRect.right;
    var allHeight = allRect.top + allRect.bottom;
    var ow = _props.outlineWidth;
    p.left = p.left > ow ? p.left - ow : 0;
    p.top = p.top > ow ? p.top - ow : 0;
    p.right = p.right < allWidth - ow ? p.right + ow : allWidth;
    p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;
    var width = p.right - p.left;
    var height = p.bottom - p.top;

    if (width > ow * 2 && height > ow * 2) {
      var leftBorderNode = outlineElements.left;
      var topBorderNode = outlineElements.top;
      var rightBorderNode = outlineElements.right;
      var bottomBorderNode = outlineElements.bottom;
      var sx = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageXOffset;
      var sy = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageYOffset;
      container.style.position = hasFixedPositionedParent ? 'fixed' : 'absolute';
      container.style.background = _props.outlineColor;
      leftBorderNode.style.width = rightBorderNode.style.width = topBorderNode.style.height = bottomBorderNode.style.height = _props.outlineWidth + 'px';
      leftBorderNode.style.left = topBorderNode.style.left = bottomBorderNode.style.left = p.left + sx + 'px';
      rightBorderNode.style.left = p.left + sx + width - ow + 'px';
      leftBorderNode.style.top = rightBorderNode.style.top = topBorderNode.style.top = p.top + sy + 'px';
      bottomBorderNode.style.top = p.top + sy + height - ow + 'px';
      leftBorderNode.style.height = rightBorderNode.style.height = height + 'px';
      topBorderNode.style.width = bottomBorderNode.style.width = width + 'px';

      this._setVisibility(true);
    } else {
      this._setVisibility(false);
    }
  };

  OutlineAPI.prototype._getDOM = function (contextElement) {
    var doc = contextElement.ownerDocument;
    var win = doc && doc.defaultView;

    if (!doc || !win || !win.__tabsterOutline) {
      return undefined;
    }

    if (!win.__tabsterOutline.style) {
      win.__tabsterOutline.style = appendStyles(doc, _props);
    }

    if (!win.__tabsterOutline.elements) {
      var outlineElements = {
        container: doc.createElement('div'),
        left: doc.createElement('div'),
        top: doc.createElement('div'),
        right: doc.createElement('div'),
        bottom: doc.createElement('div')
      };
      outlineElements.container.className = _props.outlineClass;
      outlineElements.left.className = _props.outlineClass + "__left";
      outlineElements.top.className = _props.outlineClass + "__top";
      outlineElements.right.className = _props.outlineClass + "__right";
      outlineElements.bottom.className = _props.outlineClass + "__bottom";
      outlineElements.container.appendChild(outlineElements.left);
      outlineElements.container.appendChild(outlineElements.top);
      outlineElements.container.appendChild(outlineElements.right);
      outlineElements.container.appendChild(outlineElements.bottom);
      doc.body.appendChild(outlineElements.container);
      win.__tabsterOutline.elements = outlineElements; // TODO: Make a garbage collector to remove the references
      // to the outlines which are nowhere in the DOM anymore.

      this._allOutlineElements.push(outlineElements);
    }

    return win.__tabsterOutline.elements;
  };

  OutlineAPI.prototype._removeDOM = function (contextElement) {
    var win = contextElement.ownerDocument && contextElement.ownerDocument.defaultView;
    var outline = win && win.__tabsterOutline;

    if (!outline) {
      return;
    }

    if (outline.style && outline.style.parentNode) {
      outline.style.parentNode.removeChild(outline.style);
      delete outline.style;
    }

    var outlineElements = outline && outline.elements;

    if (outlineElements) {
      if (outlineElements.container.parentNode) {
        outlineElements.container.parentNode.removeChild(outlineElements.container);
      }

      delete outline.elements;
    }
  };

  OutlineAPI._isParentChild = function (parent, child) {
    return child === parent || // tslint:disable-next-line:no-bitwise
    !!(parent.compareDocumentPosition(child) & document.DOCUMENT_POSITION_CONTAINED_BY);
  };

  return OutlineAPI;
}();

function appendStyles(document, props) {
  var style = document.createElement('style');
  style.type = 'text/css';
  style.appendChild(document.createTextNode(getOutlineStyles(props)));
  document.head.appendChild(style);
  return style;
}

function getOutlineStyles(props) {
  return "\n." + props.areaClass + " *, ." + props.areaClass + " *:focus {\noutline: none !important;\n}\n\n." + props.outlineClass + " {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: " + props.zIndex + ";\n}\n\n." + props.outlineClass + "." + props.outlineClass + "_visible {\ndisplay: block;\n}\n\n." + props.outlineClass + "__left,\n." + props.outlineClass + "__top,\n." + props.outlineClass + "__right,\n." + props.outlineClass + "__bottom {\nposition: absolute;\nbackground: inherit;\n}";
}

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

/**
 * Allows default or user focus behaviour on the DOM subtree
 * i.e. Tabster will not control focus events within an uncontrolled area
 */
var UncontrolledAPI = /*#__PURE__*/function () {
  function UncontrolledAPI(tabster) {
    /**/
  }

  return UncontrolledAPI;
}();

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Extends Window to include an internal Tabster instance.
 */

var Tabster = /*#__PURE__*/function () {
  function Tabster(win, props) {
    var _this = this;

    var _a;

    this._forgetMemorizedElements = [];
    this._version = '1.0.7';
    this._noop = false;

    this.getWindow = function () {
      if (!_this._win) {
        throw new Error('Using disposed Tabster.');
      }

      return _this._win;
    };

    this._storage = createWeakMap(win);
    this._win = win;
    var getWindow = this.getWindow;
    this.keyboardNavigation = new KeyboardNavigationState(getWindow);
    this.focusedElement = new FocusedElementState(this, getWindow);
    this.focusable = new FocusableAPI(this, getWindow);
    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);
    this.createRoot = RootAPI.createRoot;

    this.updateRoot = function (root, removed) {
      RootAPI.onRoot(_this.root, root, removed);
    };

    this.uncontrolled = new UncontrolledAPI(this);
    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;
    this.internal = {
      stopObserver: function stopObserver() {
        if (_this._unobserve) {
          _this._unobserve();

          delete _this._unobserve;
        }
      },
      resumeObserver: function resumeObserver(syncState) {
        if (!_this._unobserve) {
          var doc = getWindow().document;
          _this._unobserve = observeMutations(doc, _this, updateTabsterByAttribute, syncState);
        }
      }
    };
    this.internal.resumeObserver(false);
    startFakeWeakRefsCleanup(getWindow);
  }

  Tabster.prototype.dispose = function () {
    this.internal.stopObserver();
    var win = this._win;
    this._forgetMemorizedElements = [];

    if (win && this._forgetMemorizedTimer) {
      win.clearTimeout(this._forgetMemorizedTimer);
      delete this._forgetMemorizedTimer;
    }

    var disposeParts = {
      'outlineDispose': ['outline'],
      'crossOriginDispose': ['crossOrigin'],
      'deloserDispose': ['deloser', 'createDeloser'],
      'groupperDispose': ['groupper', 'createGroupper'],
      'moverDispose': ['mover', 'createMover'],
      'modalizerDispose': ['modalizer', 'createModalizer', 'updateModalizer'],
      'observedElementDispose': ['observedElement', 'updateObserved']
    };

    for (var _i = 0, _a = Object.keys(disposeParts); _i < _a.length; _i++) {
      var key = _a[_i];
      var disposeFunc = this[key];

      if (disposeFunc) {
        disposeFunc();

        for (var _b = 0, _c = disposeParts[key]; _b < _c.length; _b++) {
          var partKey = _c[_b];

          if (this[partKey]) {
            delete this[partKey];
          }
        }

        delete this[key];
      }
    }

    KeyboardNavigationState.dispose(this.keyboardNavigation);
    FocusableAPI.dispose(this.focusable);
    FocusedElementState.dispose(this.focusedElement);
    RootAPI.dispose(this.root);
    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);
    clearElementCache(this.getWindow);
    this._storage = new WeakMap();

    if (win) {
      disposeInstanceContext(win);
      delete win.__tabsterInstance;
      delete this._win;
    }
  };

  Tabster.dispose = function (instance) {
    instance.dispose();
  };

  Tabster.prototype.storageEntry = function (element, addremove) {
    var storage = this._storage;
    var entry = storage.get(element);

    if (entry) {
      if (addremove === false && Object.keys(entry).length === 0) {
        storage["delete"](element);
      }
    } else if (addremove === true) {
      entry = {};
      storage.set(element, entry);
    }

    return entry;
  };

  Tabster.forceCleanup = function (tabster) {
    if (!tabster._win) {
      return;
    }

    tabster._forgetMemorizedElements.push(tabster._win.document.body);

    if (tabster._forgetMemorizedTimer) {
      return;
    }

    tabster._forgetMemorizedTimer = tabster._win.setTimeout(function () {
      delete tabster._forgetMemorizedTimer;

      for (var el = tabster._forgetMemorizedElements.shift(); el; el = tabster._forgetMemorizedElements.shift()) {
        clearElementCache(tabster.getWindow, el);
        FocusedElementState.forgetMemorized(tabster.focusedElement, el);
      }
    }, 0);
    cleanupFakeWeakRefs(tabster.getWindow, true);
  };

  return Tabster;
}();
function forceCleanup(tabster) {
  // The only legit case for calling this method is when you've completely removed
  // the application DOM and not going to add the new one for a while.
  Tabster.forceCleanup(tabster);
}
/**
 * Creates an instance of Tabster, returns the current window instance if it already exists.
 */

function createTabster(win, props) {
  var existingAh = getCurrentTabster(win);

  if (existingAh) {
    {
      console.warn('Attempted to create a duplicate Tabster instance on the window');
    }

    return existingAh;
  }

  var tabster = new Tabster(win, props);
  win.__tabsterInstance = tabster;
  return tabster;
}
/**
 * Creates a new groupper instance or returns an existing one
 * @param tabster Tabster instance
 */

function getGroupper(tabster) {
  var tabsterInternal = tabster;

  if (!tabsterInternal.groupper) {
    var groupper_1 = new GroupperAPI(tabster, tabsterInternal.getWindow);
    tabsterInternal.groupper = groupper_1;
    tabsterInternal.createGroupper = GroupperAPI.createGroupper;

    tabsterInternal.groupperDispose = function () {
      GroupperAPI.dispose(groupper_1);
    };
  }

  return tabsterInternal.groupper;
}
/**
 * Creates a new mover instance or returns an existing one
 * @param tabster Tabster instance
 */

function getMover(tabster) {
  var tabsterInternal = tabster;

  if (!tabsterInternal.mover) {
    var mover_1 = new MoverAPI(tabster, tabsterInternal.getWindow);
    tabsterInternal.mover = mover_1;
    tabsterInternal.createMover = MoverAPI.createMover;

    tabsterInternal.moverDispose = function () {
      MoverAPI.dispose(mover_1);
    };
  }

  return tabsterInternal.mover;
}
function getOutline(tabster) {
  var tabsterInternal = tabster;

  if (!tabsterInternal.outline) {
    var outline_1 = new OutlineAPI(tabster);
    tabsterInternal.outline = outline_1;

    tabsterInternal.outlineDispose = function () {
      OutlineAPI.dispose(outline_1);
    };
  }

  return tabsterInternal.outline;
}
/**
 * Creates a new new deloser instance or returns an existing one
 * @param tabster Tabster instance
 * @param props Deloser props
 */

function getDeloser(tabster, props) {
  var tabsterInternal = tabster;

  if (!tabsterInternal.deloser) {
    var deloser_1 = new DeloserAPI(tabster, props);
    tabsterInternal.deloser = deloser_1;
    tabsterInternal.createDeloser = DeloserAPI.createDeloser;

    tabsterInternal.deloserDispose = function () {
      DeloserAPI.dispose(deloser_1);
    };
  }

  return tabsterInternal.deloser;
}
/**
 * Creates a new modalizer instance or returns an existing one
 * @param tabster Tabster instance
 */

function getModalizer(tabster) {
  var tabsterInternal = tabster;

  if (!tabsterInternal.modalizer) {
    var modalizer_1 = new ModalizerAPI(tabster);
    tabsterInternal.modalizer = modalizer_1;
    tabsterInternal.createModalizer = ModalizerAPI.createModalizer;

    tabsterInternal.updateModalizer = function (modalizer, removed) {
      ModalizerAPI.updateModalizer(tabsterInternal, modalizer, removed);
    };

    tabsterInternal.modalizerDispose = function () {
      ModalizerAPI.dispose(modalizer_1);
    };
  }

  return tabsterInternal.modalizer;
}
function getObservedElement(tabster) {
  var tabsterInternal = tabster;

  if (!tabsterInternal.observedElement) {
    var observedElement_1 = new ObservedElementAPI(tabster);
    tabsterInternal.observedElement = observedElement_1;
    tabsterInternal.updateObserved = observedElement_1.onObservedElementUpdate;

    tabsterInternal.observedElementDispose = function () {
      ObservedElementAPI.dispose(observedElement_1);
    };
  }

  return tabsterInternal.observedElement;
}
function getCrossOrigin(tabster) {
  var tabsterInternal = tabster;

  if (!tabsterInternal.crossOrigin) {
    getDeloser(tabster);
    getModalizer(tabster);
    getMover(tabster);
    getGroupper(tabster);
    getOutline(tabster);
    getObservedElement(tabster);
    var crossOrigin_1 = new CrossOriginAPI(tabster);
    tabsterInternal.crossOrigin = crossOrigin_1;

    tabsterInternal.crossOriginDispose = function () {
      CrossOriginAPI.dispose(crossOrigin_1);
    };
  }

  return tabsterInternal.crossOrigin;
}
function getInternal(tabster) {
  return tabster.internal;
}
function disposeTabster(tabster) {
  Tabster.dispose(tabster);
}
function getTabsterAttribute(props, plain) {
  var _a;

  var attr = JSON.stringify(props);

  if (plain === true) {
    return attr;
  }

  return _a = {}, _a[TabsterAttributeName] = attr, _a;
}
/**
 * Sets or updates Tabster attribute of the element.
 * @param element an element to set data-tabster attribute on.
 * @param newProps new Tabster props to set.
 * @param update if true, newProps will be merged with the existing props.
 *  When true and the value of a property in newProps is undefined, the property
 *  will be removed from the attribute.
 */

function setTabsterAttribute(element, newProps, update) {
  var props;

  if (update) {
    var attr = element.getAttribute(TabsterAttributeName);

    if (attr) {
      try {
        props = JSON.parse(attr);
      } catch (e) {
        /**/
      }
    }
  }

  if (!update || !props) {
    props = {};
  }

  for (var _i = 0, _a = Object.keys(newProps); _i < _a.length; _i++) {
    var key = _a[_i];
    var value = newProps[key];

    if (value) {
      props[key] = value;
    } else {
      delete props[key];
    }
  }

  if (Object.keys(props).length > 0) {
    element.setAttribute(TabsterAttributeName, getTabsterAttribute(props, true));
  } else {
    element.removeAttribute(TabsterAttributeName);
  }
}
/**
 * Returns an instance of Tabster if it already exists on the window .
 * @param win window instance that could contain an Tabster instance.
 */

function getCurrentTabster(win) {
  return win.__tabsterInstance;
}
function makeNoOp(tabster, noop) {
  var self = tabster;

  if (self._noop !== noop) {
    self._noop = noop;

    var processNode = function processNode(element) {
      if (!element.getAttribute) {
        return NodeFilter.FILTER_SKIP;
      }

      if (getTabsterOnElement(self, element) || element.hasAttribute(TabsterAttributeName)) {
        updateTabsterByAttribute(self, element);
      }

      return NodeFilter.FILTER_SKIP;
    };

    var doc = self.getWindow().document;
    var body = doc.body;
    processNode(body);
    var walker = createElementTreeWalker(doc, body, processNode);

    if (walker) {
      while (walker.nextNode()) {
        /* Iterating for the sake of calling processNode() callback. */
      }
    }
  }
}
function isNoOp(tabster) {
  return tabster._noop;
}

exports.Types = Types;
exports.createTabster = createTabster;
exports.disposeTabster = disposeTabster;
exports.forceCleanup = forceCleanup;
exports.getCrossOrigin = getCrossOrigin;
exports.getCurrentTabster = getCurrentTabster;
exports.getDeloser = getDeloser;
exports.getGroupper = getGroupper;
exports.getInternal = getInternal;
exports.getModalizer = getModalizer;
exports.getMover = getMover;
exports.getObservedElement = getObservedElement;
exports.getOutline = getOutline;
exports.getTabsterAttribute = getTabsterAttribute;
exports.isNoOp = isNoOp;
exports.makeNoOp = makeNoOp;
exports.overrideBasics = setBasics;
exports.setTabsterAttribute = setTabsterAttribute;
//# sourceMappingURL=tabster.cjs.development.js.map
