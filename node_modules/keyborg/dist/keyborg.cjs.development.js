'use strict';

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
// IE11 compat, checks if WeakRef is supported
var _canUseWeakRef = typeof WeakRef !== 'undefined';
/**
 * WeakRef wrapper around a HTMLElement that also supports IE11
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef}
 * @internal
 */

var WeakRefInstance = /*#__PURE__*/function () {
  function WeakRefInstance(instance) {
    if (_canUseWeakRef) {
      this._weakRef = new WeakRef(instance);
    } else {
      this._instance = instance;
    }
  }
  /**
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef/deref}
   */


  WeakRefInstance.prototype.deref = function () {
    var _a, _b, _c;

    var instance;

    if (this._weakRef) {
      instance = (_a = this._weakRef) === null || _a === void 0 ? void 0 : _a.deref();

      if (!instance) {
        delete this._weakRef;
      }
    } else {
      instance = this._instance;

      if ((_c = (_b = instance) === null || _b === void 0 ? void 0 : _b.isDisposed) === null || _c === void 0 ? void 0 : _c.call(_b)) {
        delete this._instance;
      }
    }

    return instance;
  };

  return WeakRefInstance;
}();

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var KEYBORG_FOCUSIN = 'keyborg:focusin';

function canOverrideNativeFocus(win) {
  var HTMLElement = win.HTMLElement;
  var origFocus = HTMLElement.prototype.focus;
  var isCustomFocusCalled = false;

  HTMLElement.prototype.focus = function focus() {
    isCustomFocusCalled = true;
  };

  var btn = win.document.createElement('button');
  btn.focus();
  HTMLElement.prototype.focus = origFocus;
  return isCustomFocusCalled;
}

var _canOverrideNativeFocus = false;
/**
 * Guarantees that the native `focus` will be used
 * Use this when trying to simulate a native keyboard focus since it does not
 * the programmatic focus flag.
 *
 * ⚠️⚠️ This focus will always activate the keyboard navigation state.
 */

function nativeFocus(element) {
  var focus = element.focus;

  if (focus.__keyborgNativeFocus) {
    focus.__keyborgNativeFocus.call(element);
  } else {
    element.focus();
  }
}
/**
 * Overrides the native `focus` and setups the keyborg focus event
 */

function setupFocusEvent(win) {
  var kwin = win;

  if (!_canOverrideNativeFocus) {
    _canOverrideNativeFocus = canOverrideNativeFocus(kwin);
  }

  var origFocus = kwin.HTMLElement.prototype.focus;

  if (origFocus.__keyborgNativeFocus) {
    // Already set up.
    return;
  }

  kwin.HTMLElement.prototype.focus = focus;
  var data = kwin.__keyborgData = {
    focusInHandler: function focusInHandler(e) {
      var _a;

      var target = e.target;

      if (!target) {
        return;
      }

      var event = document.createEvent('HTMLEvents');
      event.initEvent(KEYBORG_FOCUSIN, true, true);
      var details = {
        relatedTarget: e.relatedTarget || undefined
      };

      if (_canOverrideNativeFocus || data.lastFocusedProgrammatically) {
        details.isFocusedProgrammatically = target === ((_a = data.lastFocusedProgrammatically) === null || _a === void 0 ? void 0 : _a.deref());
        data.lastFocusedProgrammatically = undefined;
      }

      event.details = details;
      target.dispatchEvent(event);
    }
  };
  kwin.document.addEventListener('focusin', kwin.__keyborgData.focusInHandler, true);

  function focus() {
    var keyborgNativeFocusEvent = kwin.__keyborgData;

    if (keyborgNativeFocusEvent) {
      keyborgNativeFocusEvent.lastFocusedProgrammatically = new WeakRefInstance(this);
    }

    return origFocus.apply(this, arguments);
  }

  focus.__keyborgNativeFocus = origFocus;
}
/**
 * Removes keyborg event listeners and custom focus override
 * @param win The window that stores keyborg focus events
 */

function disposeFocusEvent(win) {
  var kwin = win;
  var proto = kwin.HTMLElement.prototype;
  var origFocus = proto.focus.__keyborgNativeFocus;
  var keyborgNativeFocusEvent = kwin.__keyborgData;

  if (keyborgNativeFocusEvent) {
    kwin.document.removeEventListener('focusin', keyborgNativeFocusEvent.focusInHandler, true);
    delete kwin.__keyborgData;
  }

  if (origFocus) {
    proto.focus = origFocus;
  }
}
/**
 * @param win The window that stores keyborg focus events
 * @returns The last element focused with element.focus()
 */

function getLastFocusedProgrammatically(win) {
  var _a;

  var keyborgNativeFocusEvent = win.__keyborgData;
  return keyborgNativeFocusEvent ? ((_a = keyborgNativeFocusEvent.lastFocusedProgrammatically) === null || _a === void 0 ? void 0 : _a.deref()) || null : undefined;
}

/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var KeyTab = 9;
var KeyEsc = 27;
var _dismissTimeout = 500; // When Esc is pressed and the focused is not moved
// during _dismissTimeout time, dismiss the keyboard
// navigation mode.

var _lastId = 0;
/**
 * Source of truth for all the keyborg core instances and the current keyboard navigation state
 */

var KeyborgState = /*#__PURE__*/function () {
  function KeyborgState() {
    this.__keyborgCoreRefs = {};
    this._isNavigatingWithKeyboard = false;
  }

  KeyborgState.prototype.add = function (keyborg) {
    var id = keyborg.id;

    if (!(id in this.__keyborgCoreRefs)) {
      this.__keyborgCoreRefs[id] = new WeakRefInstance(keyborg);
    }
  };

  KeyborgState.prototype.remove = function (id) {
    delete this.__keyborgCoreRefs[id];

    if (Object.keys(this.__keyborgCoreRefs).length === 0) {
      this._isNavigatingWithKeyboard = false;
    }
  };

  KeyborgState.prototype.setVal = function (isNavigatingWithKeyboard) {
    if (this._isNavigatingWithKeyboard === isNavigatingWithKeyboard) {
      return;
    }

    this._isNavigatingWithKeyboard = isNavigatingWithKeyboard;

    for (var _i = 0, _a = Object.keys(this.__keyborgCoreRefs); _i < _a.length; _i++) {
      var id = _a[_i];
      var ref = this.__keyborgCoreRefs[id];
      var keyborg = ref.deref();

      if (keyborg) {
        keyborg.update(isNavigatingWithKeyboard);
      } else {
        this.remove(id);
      }
    }
  };

  KeyborgState.prototype.getVal = function () {
    return this._isNavigatingWithKeyboard;
  };

  return KeyborgState;
}();

var _state = /*#__PURE__*/new KeyborgState();
/**
 * Manages a collection of Keyborg instances in a window/document and updates keyborg state
 */


var KeyborgCore = /*#__PURE__*/function () {
  function KeyborgCore(win) {
    var _this = this;

    this._isMouseUsed = false;

    this._onFocusIn = function (e) {
      if (_this._isMouseUsed) {
        _this._isMouseUsed = false;
        return;
      }

      if (_state.getVal()) {
        return;
      }

      var details = e.details;

      if (!details.relatedTarget) {
        return;
      }

      if (details.isFocusedProgrammatically || details.isFocusedProgrammatically === undefined) {
        // The element is focused programmatically, or the programmatic focus detection
        // is not working.
        return;
      }

      _state.setVal(true);
    };

    this._onMouseDown = function (e) {
      if (e.buttons === 0 || e.clientX === 0 && e.clientY === 0 && e.screenX === 0 && e.screenY === 0) {
        // This is most likely an event triggered by the screen reader to perform
        // an action on an element, do not dismiss the keyboard navigation mode.
        return;
      }

      _this._isMouseUsed = true;

      _state.setVal(false);
    };

    this._onKeyDown = function (e) {
      var isNavigatingWithKeyboard = _state.getVal();

      if (!isNavigatingWithKeyboard && e.keyCode === KeyTab) {
        _state.setVal(true);
      } else if (isNavigatingWithKeyboard && e.keyCode === KeyEsc) {
        _this._scheduleDismiss();
      }
    };

    this.id = 'c' + ++_lastId;
    this._win = win;
    var doc = win.document;
    doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true); // Capture!

    doc.addEventListener('mousedown', this._onMouseDown, true); // Capture!

    win.addEventListener('keydown', this._onKeyDown, true); // Capture!

    setupFocusEvent(win);

    _state.add(this);
  }

  KeyborgCore.prototype.dispose = function () {
    var win = this._win;

    if (win) {
      if (this._dismissTimer) {
        win.clearTimeout(this._dismissTimer);
        this._dismissTimer = undefined;
      }

      disposeFocusEvent(win);
      var doc = win.document;
      doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true); // Capture!

      doc.removeEventListener('mousedown', this._onMouseDown, true); // Capture!

      win.removeEventListener('keydown', this._onKeyDown, true); // Capture!

      delete this._win;

      _state.remove(this.id);
    }
  };

  KeyborgCore.prototype.isDisposed = function () {
    return !!this._win;
  };
  /**
   * Updates all keyborg instances with the keyboard navigation state
   */


  KeyborgCore.prototype.update = function (isNavigatingWithKeyboard) {
    var _a, _b;

    var keyborgs = (_b = (_a = this._win) === null || _a === void 0 ? void 0 : _a.__keyborg) === null || _b === void 0 ? void 0 : _b.refs;

    if (keyborgs) {
      for (var _i = 0, _c = Object.keys(keyborgs); _i < _c.length; _i++) {
        var id = _c[_i];
        Keyborg.update(keyborgs[id], isNavigatingWithKeyboard);
      }
    }
  };

  KeyborgCore.prototype._scheduleDismiss = function () {
    var _this = this;

    var win = this._win;

    if (win) {
      if (this._dismissTimer) {
        win.clearTimeout(this._dismissTimer);
        this._dismissTimer = undefined;
      }

      var was_1 = win.document.activeElement;
      this._dismissTimer = win.setTimeout(function () {
        _this._dismissTimer = undefined;
        var cur = win.document.activeElement;

        if (was_1 && cur && was_1 === cur) {
          // Esc was pressed, currently focused element hasn't changed.
          // Just dismiss the keyboard navigation mode.
          _state.setVal(false);
        }
      }, _dismissTimeout);
    }
  };

  return KeyborgCore;
}();
/**
 * Used to determine the keyboard navigation state
 */


var Keyborg = /*#__PURE__*/function () {
  function Keyborg(win) {
    var _a;

    this._cb = [];
    this._id = 'k' + ++_lastId;
    this._win = win;
    var current = win.__keyborg;

    if (current) {
      this._core = current.core;
      current.refs[this._id] = this;
    } else {
      this._core = new KeyborgCore(win);
      win.__keyborg = {
        core: this._core,
        refs: (_a = {}, _a[this._id] = this, _a)
      };
    }
  }

  Keyborg.create = function (win) {
    return new Keyborg(win);
  };

  Keyborg.dispose = function (instance) {
    instance.dispose();
  };
  /**
   * Updates all subscribed callbacks with the keyboard navigation state
   */


  Keyborg.update = function (instance, isNavigatingWithKeyboard) {
    instance._cb.forEach(function (callback) {
      return callback(isNavigatingWithKeyboard);
    });
  };

  Keyborg.prototype.dispose = function () {
    var _a;

    var current = (_a = this._win) === null || _a === void 0 ? void 0 : _a.__keyborg;

    if (current === null || current === void 0 ? void 0 : current.refs[this._id]) {
      delete current.refs[this._id];

      if (Object.keys(current.refs).length === 0) {
        current.core.dispose();
        delete this._win.__keyborg;
      }
    } else {
      console.error("Keyborg instance " + this._id + " is being disposed incorrectly.");
    }

    this._cb = [];
    delete this._core;
    delete this._win;
  };
  /**
   * @returns Whether the user is navigating with keyboard
   */


  Keyborg.prototype.isNavigatingWithKeyboard = function () {
    return _state.getVal();
  };
  /**
   * @param callback - Called when the keyboard navigation state changes
   */


  Keyborg.prototype.subscribe = function (callback) {
    this._cb.push(callback);
  };
  /**
   * @param callback - Registered with subscribe
   */


  Keyborg.prototype.unsubscribe = function (callback) {
    var index = this._cb.indexOf(callback);

    if (index >= 0) {
      this._cb.splice(index, 1);
    }
  };
  /**
   * Manually set the keyboard navigtion state
   */


  Keyborg.prototype.setVal = function (isNavigatingWithKeyboard) {
    _state.setVal(isNavigatingWithKeyboard);
  };

  return Keyborg;
}();
function createKeyborg(win) {
  return Keyborg.create(win);
}
function disposeKeyborg(instance) {
  Keyborg.dispose(instance);
}

exports.KEYBORG_FOCUSIN = KEYBORG_FOCUSIN;
exports.Keyborg = Keyborg;
exports.createKeyborg = createKeyborg;
exports.disposeKeyborg = disposeKeyborg;
exports.getLastFocusedProgrammatically = getLastFocusedProgrammatically;
exports.nativeFocus = nativeFocus;
//# sourceMappingURL=keyborg.cjs.development.js.map
