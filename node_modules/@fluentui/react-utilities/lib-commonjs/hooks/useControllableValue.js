"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useControllableValue = void 0;

var React = /*#__PURE__*/require("react");

var useConst_1 = /*#__PURE__*/require("./useConst");

function useControllableValue(controlledValue, defaultUncontrolledValue, onChange) {
  var _a = React.useState(defaultUncontrolledValue),
      value = _a[0],
      setValue = _a[1];

  var isControlled = useIsControlled(controlledValue);
  var currentValue = isControlled ? controlledValue : value; // Duplicate the current value and onChange in refs so they're accessible from
  // setValueOrCallOnChange without creating a new callback every time

  var valueRef = React.useRef(currentValue);
  var onChangeRef = React.useRef(onChange);
  React.useEffect(function () {
    valueRef.current = currentValue;
    onChangeRef.current = onChange;
  }); // To match the behavior of the setter returned by React.useState, this callback's identity
  // should never change. This means it MUST NOT directly reference variables that can change.

  var setValueOrCallOnChange = useConst_1.useConst(function () {
    return function (update, ev) {
      // Assuming here that TValue is not a function, because a controllable value will typically
      // be something a user can enter as input
      var newValue = typeof update === 'function' ? update(valueRef.current) : update;

      if (onChangeRef.current) {
        onChangeRef.current(ev, newValue);
      }

      if (!isControlled) {
        setValue(newValue);
      }
    };
  });
  return [currentValue, setValueOrCallOnChange];
}

exports.useControllableValue = useControllableValue;
/**
 * Helper hook to handle previous comparison of controlled/uncontrolled
 * Prints an error when isControlled value switches between subsequent renders
 */

var useIsControlled = function (controlledValue) {
  var isControlled = useConst_1.useConst(controlledValue !== undefined);

  if (process.env.NODE_ENV !== 'production') {
    // We don't want these warnings in production even though it is against native behaviour
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(function () {
      if (isControlled !== (controlledValue !== undefined)) {
        var error = new Error();
        var controlWarning = isControlled ? 'a controlled value to be uncontrolled' : 'an uncontrolled value to be controlled';
        var undefinedWarning = isControlled ? 'defined to an undefined' : 'undefined to a defined'; // eslint-disable-next-line no-console

        console.error([// Default react error
        'A component is changing ' + controlWarning + '. This is likely caused by the value', 'changing from ' + undefinedWarning + ' value, which should not happen.', 'Decide between using a controlled or uncontrolled input element for the lifetime of the component.', 'More info: https://reactjs.org/link/controlled-components', error.stack].join(' '));
      }
    }, [isControlled, controlledValue]);
  }

  return isControlled;
};
//# sourceMappingURL=useControllableValue.js.map