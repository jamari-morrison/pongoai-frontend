import { DispatchWithoutAction } from 'react';
import * as React_2 from 'react';

/**
 * An array of A tag properties and events.
 *
 * @public
 */
export declare const anchorProperties: Record<string, number>;

/**
 * Apply the trigger props to the children, either by calling the render function, or cloning with the new props.
 */
export declare const applyTriggerPropsToChildren: <TTriggerProps>(children: React_2.ReactElement<any, string | ((props: any) => React_2.ReactElement<any, string | any | (new (props: any) => React_2.Component<any, any, any>)> | null) | (new (props: any) => React_2.Component<any, any, any>)> | ((props: TTriggerProps) => React_2.ReactNode) | null | undefined, triggerProps: TTriggerProps) => React_2.ReactNode;

/**
 * Helper type for inferring the type of the as prop from a Props type.
 *
 * For example:
 * ```
 * type Example<T> = T extends AsIntrinsicElement<infer As> ? As : never;
 * ```
 */
export declare type AsIntrinsicElement<As extends keyof JSX.IntrinsicElements> = {
    as?: As;
};

/**
 * An array of AUDIO tag properties and events.

 * @public
 */
export declare const audioProperties: Record<string, number>;

/**
 * An array of events that are allowed on every html element type.
 *
 * @public
 */
export declare const baseElementEvents: Record<string, number>;

/**
 * An array of element attributes which are allowed on every html element type.
 *
 * @public
 */
export declare const baseElementProperties: Record<string, number>;

export declare type BaseSlotsCompat = {
    root: React_2.ElementType;
};

/**
 * An array of BUTTON tag properties and events.
 *
 * @public
 */
export declare const buttonProperties: Record<string, number>;

/**
 * Verifies if an application can use DOM.
 */
export declare function canUseDOM(): boolean;

export declare type ChangeCallback<TElement extends HTMLElement, TValue, TEvent extends React_2.SyntheticEvent<TElement> | undefined> = (ev: TEvent, newValue: TValue | undefined) => void;

/**
 * Clamps `value` to a number between the min and max.
 *
 * @param value - the value to be clamped
 * @param min - the lowest valid value
 * @param max - the highest valid value
 */
export declare const clamp: (value: number, min: number, max: number) => number;

export declare const colGroupProperties: Record<string, number>;

export declare const colProperties: Record<string, number>;

export declare type ComponentProps<Shorthands extends ObjectShorthandPropsRecord, Primary extends keyof Shorthands = 'root'> = Omit<{
    [Key in keyof Shorthands]?: ShorthandProps<NonNullable<Shorthands[Key]>>;
}, Primary> & PropsWithoutRef<Shorthands[Primary]>;

export declare type ComponentPropsCompat = {
    as?: React_2.ElementType;
    className?: string;
    children?: React_2.ReactNode;
};

export declare type ComponentState<Shorthands extends ObjectShorthandPropsRecord> = {
    components?: {
        [Key in keyof Shorthands]-?: React_2.ComponentType<NonNullable<Shorthands[Key]> extends ObjectShorthandProps<infer P> ? P : NonNullable<Shorthands[Key]>> | (NonNullable<Shorthands[Key]> extends AsIntrinsicElement<infer As> ? As : keyof JSX.IntrinsicElements);
    };
} & Shorthands;

/**
 * Converts a components Props type to a State type:
 * * Ensures the specified ShorthandProps are of type ObjectShorthandProps<T>
 * * Marks the given defaulted props as required (-?)
 *
 * @template Props - The component's Props type
 * @template ShorthandPropNames - The keys of Props that correspond to ShorthandProps
 * @template DefaultedPropNames - The keys of Props that will always have a default value provided
 */
export declare type ComponentStateCompat<Props, ShorthandPropNames extends keyof Props = never, DefaultedPropNames extends keyof ResolvedShorthandPropsCompat<Props, ShorthandPropNames> = never> = RequiredPropsCompat<ResolvedShorthandPropsCompat<Props, ShorthandPropNames>, DefaultedPropNames>;

/**
 * Matches any shorthand props type.
 *
 * This should ONLY be used in type templates as in `extends DefaultObjectShorthandProps`;
 * it shouldn't be used as the type of a slot.
 */
export declare type DefaultObjectShorthandProps = ObjectShorthandProps<{
    children?: React_2.ReactNode;
    as?: keyof JSX.IntrinsicElements;
}>;

/**
 * Default context value to use in case there is no SSRProvider. This is fine for client-only apps.
 *
 * @internal
 */
export declare const defaultSSRContextValue: SSRContextValue;

/**
 * Default value can be a value or an initializer
 */
declare type DefaultValue<TValue> = TValue | (() => TValue);

/**
 * An array of DIV tag properties and events.
 *
 * @public
 */
export declare const divProperties: Record<string, number>;

/**
 * An array of FORM tag properties and events.
 *
 * @public
 */
export declare const formProperties: Record<string, number>;

declare type GenericDictionary = Record<string, any>;

declare type GenericDictionary_2 = Record<string, any>;

/**
 * Given an element tagname and user props, filters the props to only allowed props for the given
 * element type.
 * @param tagName - Tag name (e.g. "div")
 * @param props - Props object
 * @param excludedPropNames - List of props to disallow
 */
export declare function getNativeElementProps<TAttributes extends React_2.HTMLAttributes<any>>(tagName: string, props: {}, excludedPropNames?: string[]): TAttributes;

/**
 * Gets native supported props for an html element provided the allowance set. Use one of the property
 * sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given
 * props set. Note that all data- and aria- prefixed attributes will be allowed.
 * NOTE: getNativeProps should always be applied first when adding props to a react component. The
 * non-native props should be applied second. This will prevent getNativeProps from overriding your custom props.
 * For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to
 * the component after an onClick function is added, then the getNativeProps onClick will override it.
 *
 * @public
 * @param props - The unfiltered input props
 * @param allowedPropsNames - The array or record of allowed prop names.
 * @returns The filtered props
 */
export declare function getNativeProps<T extends Record<string, any>>(props: Record<string, any>, allowedPropNames: string[] | Record<string, number>, excludedPropNames?: string[]): T;

/**
 * Finds and swaps a provided key for it's right to left format.
 */
export declare const getRTLSafeKey: (key: string, dir: 'ltr' | 'rtl') => string;

/**
 * Given the state and an array of slot names, will break out `slots` and `slotProps`
 * collections.
 *
 * The root is derived from a mix of `components` props and `as` prop.
 *
 * Slots will render as null if they are rendered as primitives with undefined children.
 *
 * The slotProps will always omit the `as` prop within them, and for slots that are string
 * primitives, the props will be filtered according the the slot type. For example, if the
 * slot is rendered `as: 'a'`, the props will be filtered for acceptable anchor props.
 *
 * @param state - State including slot definitions
 * @param slotNames - Name of which props are slots
 * @returns An object containing the `slots` map and `slotProps` map.
 */
export declare function getSlots<R extends ObjectShorthandPropsRecord>(state: ComponentState<R>, slotNames?: (keyof R)[]): {
    slots: Slots<R>;
    slotProps: SlotProps<R>;
};

/**
 * Given the state and an array of slot names, will break out `slots` and `slotProps`
 * collections.
 *
 * The root is always derived from the `as` prop.
 *
 * Slots will render as null if they are rendered as primitives with undefined children.
 *
 * The slotProps will always omit the `as` prop within them, and for slots that are string
 * primitives, the props will be filtered according the the slot type. For example, if the
 * slot is rendered `as: 'a'`, the props will be filtered for acceptable anchor props.
 *
 * @param state - State including slot definitions
 * @param slotNames - Name of which props are slots
 * @returns An object containing the `slots` map and `slotProps` map.
 */
export declare const getSlotsCompat: (state: GenericDictionary, slotNames?: readonly string[] | undefined) => {
    slots: Record<string, any>;
    slotProps: Record<string, any>;
};

/**
 * An array of HTML element properties and events.
 *
 * @public
 */
export declare const htmlElementProperties: Record<string, number>;

/**
 * An array of IFRAME tag properties and events.
 *
 * @public
 */
export declare const iframeProperties: Record<string, number>;

/**
 * @deprecated Use imgProperties for img elements.
 */
export declare const imageProperties: Record<string, number>;

/**
 * An array of IMAGE tag properties and events.
 *
 * @public
 */
export declare const imgProperties: Record<string, number>;

/**
 * An array of INPUT tag properties and events.
 *
 * @public
 */
export declare const inputProperties: Record<string, number>;

/**
 * Define the slot arguments for a slot that supports one or more intrinsic element types, such as 'div'.
 * For slots that support custom components, use {@link ObjectShorthandProps} instead.
 *
 * The first param is the slot's default type if no `as` prop is specified.
 * The second param is an optional union of alternative types that can be specified for the `as` prop.
 *
 * ```
 * IntrinsicShorthandProps<'div'> // Slot is always div
 * IntrinsicShorthandProps<'button', 'a'> // Defaults to button, but allows as="a" with anchor-specific props
 * IntrinsicShorthandProps<'label', 'span' | 'div'>; // Defaults to label, but allows as="span" or as="div"
 * ```
 */
export declare type IntrinsicShorthandProps<DefaultAs extends keyof JSX.IntrinsicElements, AlternateAs extends keyof JSX.IntrinsicElements = never> = IsSingleton<DefaultAs> extends false ? 'Error: first parameter to IntrinsicShorthandProps must be a single element type, not a union of types' : ({
    as?: DefaultAs;
} & ObjectShorthandProps<React_2.PropsWithRef<JSX.IntrinsicElements[DefaultAs]>>) | {
    [As in AlternateAs]: {
        as: As;
    } & ObjectShorthandProps<React_2.PropsWithRef<JSX.IntrinsicElements[As]>>;
}[AlternateAs];

/**
 * Evaluates to true if the given type contains exactly one string, or false if it is a union of strings.
 *
 * ```
 * IsSingleton<'a'> // true
 * IsSingleton<'a' | 'b' | 'c'> // false
 * ```
 */
export declare type IsSingleton<T extends string> = {
    [K in T]: Exclude<T, K> extends never ? true : false;
}[T];

/**
 * An array of LABEL tag properties and events.
 *
 * @public
 */
export declare const labelProperties: Record<string, number>;

/**
 * An array of LI tag properties and events.
 *
 * @public
 */
export declare const liProperties: Record<string, number>;

/**
 * Helper which deep clones props, but respectively assigns JSX, object refs, and class names
 * appropriately.
 *
 * @param target - the target object to merge onto.
 * @param propSets - one or more prop sets to deep merge onto the target.
 */
export declare const makeMergeProps: <TState>(options?: MergePropsOptions<TState>) => (target: TState, ...propSets: (Partial<TState> | undefined)[]) => TState;

/**
 * Backwards-compatible version of makeMergeProps that has less restrictive type checking
 *
 * @deprecated Use makeMergeProps instead
 */
export declare const makeMergePropsCompat: <TState = Record<string, any>>(options?: MergePropsOptions<Record<string, any>> | undefined) => (target: GenericDictionary_2, ...propSets: (GenericDictionary_2 | undefined)[]) => TState;

export declare type MergePropsOptions<TState> = {
    /**
     * A list of props to deep merge. By default, `style` will
     * always be deep merged so it's not required to be provided.
     */
    deepMerge?: readonly (keyof TState)[];
};

/**
 * Simple constant function for returning null, used to render empty templates in JSX.
 */
export declare const nullRender: () => null;

/**
 * Defines the slot props for a slot that supports a Component type.
 *
 * For intrinsic elements like 'div', use {@link IntrinsicShorthandProps} instead.
 */
export declare type ObjectShorthandProps<Props extends {
    children?: React_2.ReactNode;
} = {}> = Props & {
    children?: Props['children'] | ShorthandRenderFunction<Props>;
};

export declare type ObjectShorthandPropsCompat<TProps extends ComponentPropsCompat = {}> = TProps & Omit<ComponentPropsCompat, 'children'> & {
    children?: TProps['children'] | ShorthandRenderFunctionCompat<TProps>;
};

export declare type ObjectShorthandPropsRecord = Record<string, DefaultObjectShorthandProps | undefined>;

/**
 * An array of OL tag properties and events.
 *
 * @public
 */
export declare const olProperties: Record<string, number>;

/**
 * Tiny helper to do the minimal amount of work in duplicating an object but omitting some
 * props. This ends up faster than using object ...rest or reduce to filter.
 *
 * This behaves very much like filteredAssign, but does not merge many objects together,
 * uses an exclusion object map, and avoids spreads all for optimal performance.
 *
 * See perf test for background:
 * https://jsperf.com/omit-vs-rest-vs-reduce/1
 *
 * @param obj - The object to clone
 * @param exclusions - The array of keys to exclude
 */
export declare function omit<TObj extends Record<string, any>, Exclusions extends (keyof TObj)[]>(obj: TObj, exclusions: Exclusions): Omit<TObj, Exclusions[number]>;

/**
 * Similar to React.Children.only, but drills into fragments rather than treating them as a single child
 */
export declare const onlyChild: <P>(child: string | number | boolean | {} | React_2.ReactNodeArray | React_2.ReactPortal | React_2.ReactElement<P, string | ((props: any) => React_2.ReactElement<any, string | any | (new (props: any) => React_2.Component<any, any, any>)> | null) | (new (props: any) => React_2.Component<any, any, any>)> | null | undefined) => React_2.ReactElement<P, string | ((props: any) => React_2.ReactElement<any, string | any | (new (props: any) => React_2.Component<any, any, any>)> | null) | (new (props: any) => React_2.Component<any, any, any>)>;

export declare const optionProperties: Record<string, number>;

/**
 * Removes the 'ref' prop from the given Props type, leaving unions intact (such as the discriminated union created by
 * IntrinsicShorthandProps). This allows IntrinsicShorthandProps to be used with React.forwardRef.
 *
 * The conditional "extends unknown" (always true) exploits a quirk in the way TypeScript handles conditional
 * types, to prevent unions from being expanded.
 */
export declare type PropsWithoutRef<P> = 'ref' extends keyof P ? (P extends unknown ? Omit<P, 'ref'> : P) : P;

/**
 * A Ref function which can be treated like a ref object in that it has an attached
 * current property, which will be updated as the ref is evaluated.
 */
export declare type RefObjectFunction<T> = React_2.RefObject<T> & ((value: T) => void);

/**
 * Helper type to mark the given props as required.
 * Similar to Required<T> except it only requires a subset of the props.
 */
export declare type RequiredPropsCompat<T, K extends keyof T> = Omit<T, K> & {
    [P in K]-?: T[P];
};

/**
 * Resets generated IDs, should be used only in tests.
 *
 * @private
 */
export declare function resetIdsForTests(): void;

/**
 * Helper type to convert the given props of type ShorthandProps into ObjectShorthandProps
 */
export declare type ResolvedShorthandPropsCompat<T, K extends keyof T> = Omit<T, K> & {
    [P in K]: T[P] extends ShorthandPropsCompat<infer U> ? ObjectShorthandPropsCompat<U> : T[P];
};

/**
 * Resolves ShorthandProps into ObjectShorthandProps, to ensure normalization of the signature
 * being passed down to getSlots method
 * @param value - the base ShorthandProps
 * @param options - options to resolve ShorthandProps
 */
export declare function resolveShorthand<Props extends DefaultObjectShorthandProps, Required extends boolean = false>(value: ShorthandProps<Props>, options?: ResolveShorthandOptions<Props, Required>): Required extends false ? Props | undefined : Props;

export declare type ResolveShorthandOptions<Props extends Record<string, any>, Required extends boolean = false> = {
    required?: Required;
    defaultProps?: Props;
};

/**
 * Ensures that the given slots are represented using object syntax. This ensures that
 * the object can be merged along with other objects.
 * @param props - The incoming props
 * @param shorthandPropNames - An array of prop names to apply simplification to
 */
export declare const resolveShorthandProps: <TProps, TShorthandPropNames extends keyof TProps>(props: TProps, shorthandPropNames: readonly TShorthandPropNames[]) => ResolvedShorthandPropsCompat<TProps, TShorthandPropNames>;

/**
 * An array of SELECT tag properties and events.
 *
 * @public
 */
export declare const selectProperties: Record<string, number>;

export declare type ShorthandProps<Props extends DefaultObjectShorthandProps> = React_2.ReactChild | React_2.ReactNodeArray | React_2.ReactPortal | number | null | undefined | Props;

export declare type ShorthandPropsCompat<TProps extends ComponentPropsCompat = {}> = React_2.ReactChild | React_2.ReactNodeArray | React_2.ReactPortal | number | null | undefined | ObjectShorthandPropsCompat<TProps>;

export declare type ShorthandRenderFunction<Props> = (Component: React_2.ElementType<Props>, props: Omit<Props, 'children' | 'as'>) => React_2.ReactNode;

export declare type ShorthandRenderFunctionCompat<TProps> = (Component: React_2.ElementType<TProps>, props: TProps) => React_2.ReactNode;

/**
 * Checks if the keyboard event should preventDefault() for Enter and Spacebar keys
 *
 * Useful for situations where a keydown needs to be transformed to a click event
 */
export declare function shouldPreventDefaultOnKeyDown(e: KeyboardEvent | React_2.KeyboardEvent): boolean;

declare type SlotProps<S extends ObjectShorthandPropsRecord> = {
    [K in keyof S]-?: NonNullable<S[K]> extends AsIntrinsicElement<infer As> ? UnionToIntersection<JSX.IntrinsicElements[As]> : NonNullable<S[K]> extends ObjectShorthandProps<infer P> ? P : never;
};

export declare type SlotPropsCompat<TSlots extends BaseSlotsCompat, TProps, TRootProps extends React_2.HTMLAttributes<HTMLElement>> = {
    [key in keyof Omit<TSlots, 'root'>]: key extends keyof TProps ? TProps[key] : any;
} & {
    root: TRootProps;
};

export declare type Slots<S extends ObjectShorthandPropsRecord> = {
    [K in keyof S]-?: NonNullable<S[K]> extends AsIntrinsicElement<infer As> ? As : S[K] extends ObjectShorthandProps<infer P> ? React_2.ElementType<NonNullable<P>> : React_2.ElementType<NonNullable<S[K]>>;
};

export declare const SSRContext: React_2.Context<SSRContextValue>;

/**
 * To support SSR, the auto incrementing id counter is stored in a context. This allows it to be reset on every request
 * to ensure the client and server are consistent.
 *
 * @internal
 */
export declare type SSRContextValue = {
    current: number;
};

/**
 * When using SSR with Fluent UI, applications must be wrapped in an SSRProvider. This ensures that auto generated ids
 * are consistent between the client and server.
 *
 * @public
 */
export declare const SSRProvider: React_2.FC;

/**
 * An array of TABLE tag properties and events.
 *
 * @public
 */
export declare const tableProperties: Record<string, number>;

/**
 * An array of TD tag properties and events.
 *
 * @public
 */
export declare const tdProperties: Record<string, number>;

/**
 * An array of TEXTAREA tag properties and events.
 *
 * @public
 */
export declare const textAreaProperties: Record<string, number>;

/**
 * An array of TH tag properties and events.
 *
 * @public
 */
export declare const thProperties: Record<string, number>;

/**
 * An array of TR tag properties and events.
 *
 * @public
 */
export declare const trProperties: Record<string, number>;

/**
 * Converts a union type (`A | B | C`) to an intersection type (`A & B & C`)
 */
export declare type UnionToIntersection<U> = (U extends unknown ? (x: U) => U : never) extends (x: infer I) => U ? I : never;

/**
 * Hook to store a value and generate callbacks for setting the value to true or false.
 * The identity of the callbacks will always stay the same.
 *
 * @param initialState - Initial value
 * @returns Array with the current value and an object containing the updater callbacks.
 */
export declare function useBoolean(initialState: boolean): [boolean, UseBooleanCallbacks];

/** Updater callbacks returned by `useBoolean`. */
export declare type UseBooleanCallbacks = {
    /** Set the value to true. Always has the same identity. */
    setTrue: () => void;
    /** Set the value to false. Always has the same identity. */
    setFalse: () => void;
    /** Toggle the value. Always has the same identity. */
    toggle: () => void;
};

/**
 * Hook to initialize and return a constant value. Unlike `React.useMemo`, this is guaranteed to
 * always return the same value (and if the initializer is a function, only call it once).
 * This is similar to setting a private member in a class constructor.
 *
 * If the value should ever change based on dependencies, use `React.useMemo` instead.
 *
 * @param initialValue - Initial value, or function to get the initial value. Similar to `useState`,
 * only the value/function passed in the first time this is called is respected.
 * @returns The value. The identity of this value will always be the same.
 */
export declare function useConst<T>(initialValue: T | (() => T)): T;

/**
 * A useState 'like' hook that allows optional user control
 * Useful for components which allow uncontrolled and controlled behaviour for users
 * @returns - https://reactjs.org/docs/hooks-state.html
 */
export declare const useControllableState: <State>(options: UseControllableStateOptions<State>) => [State, React_2.Dispatch<React_2.SetStateAction<State>>];

export declare type UseControllableStateOptions<State> = {
    /**
     * User provided default state or factory initializer
     */
    defaultState?: State | (() => State);
    /**
     * User provided controllable state, undefined state means internal state will be used
     */
    state: State | undefined;
    /**
     * Used to initialize state if all user provided states are undefined
     */
    initialState: State;
};

/**
 * Hook to manage a value that could be either controlled or uncontrolled, such as a checked state or
 * text box string.
 * @param controlledValue - The controlled value passed in the props. This value will always be used if provided,
 * and the internal state will be updated to reflect it.
 * @param defaultUncontrolledValue - Initial value for the internal state in the uncontrolled case.
 * @returns An array of the current value and an updater callback. Like `React.useState`, the updater
 * callback always has the same identity, and it can take either a new value, or a function which
 * is passed the previous value and returns the new value.
 * @see https://reactjs.org/docs/uncontrolled-components.html
 */
export declare function useControllableValue<TValue, TElement extends HTMLElement>(controlledValue: TValue, defaultUncontrolledValue: DefaultValue<TValue>): Readonly<[TValue, (update: React_2.SetStateAction<TValue>) => void]>;

export declare function useControllableValue<TValue, TElement extends HTMLElement, TEvent extends React_2.SyntheticEvent<TElement> | undefined>(controlledValue: TValue, defaultUncontrolledValue: DefaultValue<TValue>, onChange: ChangeCallback<TElement, TValue, TEvent>): Readonly<[TValue, (update: React_2.SetStateAction<TValue>, ev?: React_2.FormEvent<TElement>) => void]>;

/**
 * https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback
 *
 * Modified `useCallback` that can be used when dependencies change too frequently. Can occur when
 * e.g. user props are dependencies which could change on every render
 * e.g. volatile values (i.e. useState/useDispatch) are dependencies which could change frequently
 *
 * This should not be used often, but can be a useful re-render optimization since the callback is a ref and
 * will not be invalidated between re-renders
 *
 * @param fn - The callback function that will be used
 */
export declare const useEventCallback: <Args extends unknown[], Return>(fn: (...args: Args) => Return) => (...args: Args) => Return;

/**
 * Checks if components was mounted the first time.
 * Since concurrent mode will be released in the future this needs to be verified
 * Currently (React 17) will always render the initial mount once
 * https://codesandbox.io/s/heuristic-brook-s4w0q?file=/src/App.jsx
 * https://codesandbox.io/s/holy-grass-8nieu?file=/src/App.jsx
 *
 * @example
 * const isFirstMount = useFirstMount();
 */
export declare function useFirstMount(): boolean;

/**
 * Forces a re-render, similar to `forceUpdate` in class components.
 */
export declare function useForceUpdate(): DispatchWithoutAction;

/**
 * Hook to generate a unique ID.
 *
 * @param prefix - Optional prefix for the ID
 * @param providedId - Optional id provided by a parent component. Defaults to the provided value if present,
 *  without conditioning the hook call
 * @returns The ID
 */
export declare function useId(prefix?: string, providedId?: string): string;

/**
 * React currently throws a warning when using useLayoutEffect on the server. To get around it, we can conditionally
 * useEffect on the server (no-op) and useLayoutEffect in the browser. We occasionally need useLayoutEffect to
 * ensure we don't get a render flash for certain operations, but we may also need affected components to render on
 * the server.
 *
 * https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85
 * https://github.com/reduxjs/react-redux/blob/master/src/utils/useIsomorphicLayoutEffect.js
 */
export declare const useIsomorphicLayoutEffect: typeof React_2.useEffect;

/**
 * Returns whether the component is currently being server side rendered or hydrated on the client. Can be used to delay
 * browser-specific rendering until after hydration. May cause re-renders on a client when is used within SSRProvider.
 */
export declare function useIsSSR(): boolean;

/**
 * React hook to merge multiple React refs (either MutableRefObjects or ref callbacks) into a single ref callback that
 * updates all provided refs
 * @param refs - Refs to collectively update with one ref value.
 * @returns A function with an attached "current" prop, so that it can be treated like a RefObject.
 */
export declare function useMergedRefs<T>(...refs: (React_2.Ref<T> | undefined)[]): RefObjectFunction<T>;

/**
 * Hook which asynchronously executes a callback once the component has been mounted.
 *
 * @param callback - Function to call before mount.
 */
export declare const useMount: (callback: () => void) => void;

export declare type UseOnClickOrScrollOutsideOptions = {
    /**
     * The element to listen for the click event
     */
    element: Document | undefined;
    /**
     * Refs to elements that check if the click is outside
     */
    refs: React_2.MutableRefObject<HTMLElement | undefined | null>[];
    /**
     * By default uses element.contains, but custom contain function can be provided
     * @param parentRef - provided parent ref
     * @param child - event target element
     */
    contains?(parent: HTMLElement | null, child: HTMLElement): boolean;
    /**
     * Disables event listeners
     */
    disabled?: boolean;
    /**
     * Called if the click is outside the element refs
     */
    callback: (ev: MouseEvent | TouchEvent) => void;
};

/**
 * Utility to perform checks where a click/touch event was made outside a component
 */
export declare const useOnClickOutside: (options: UseOnClickOrScrollOutsideOptions) => void;

/**
 * Utility to perform checks where a click/touch event was made outside a component
 */
export declare const useOnScrollOutside: (options: UseOnClickOrScrollOutsideOptions) => void;

export declare const usePrevious: <ValueType = unknown>(value: ValueType) => ValueType | null;

/**
 * @internal
 */
export declare function useSSRContext(): SSRContextValue;

/**
 * Helper to manage a browser timeout.
 * Ensures that the timeout isn't set multiple times at once,
 * and is cleaned up when the component is unloaded.
 *
 * @returns A pair of [setTimeout, clearTimeout] that are stable between renders.
 */
export declare function useTimeout(): readonly [(fn: () => void, delay: number) => void, () => void];

/**
 * Hook which synchronously executes a callback when the component is about to unmount.
 *
 * @param callback - Function to call during unmount.
 */
export declare const useUnmount: (callback: () => void) => void;

/**
 * An array of VIDEO tag properties and events.
 *
 * @public
 */
export declare const videoProperties: Record<string, number>;

export { }
