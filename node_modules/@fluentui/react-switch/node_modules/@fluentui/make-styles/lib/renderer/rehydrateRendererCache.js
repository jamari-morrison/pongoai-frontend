// Regexps to extract names of classes and animations
// https://github.com/styletron/styletron/blob/e0fcae826744eb00ce679ac613a1b10d44256660/packages/styletron-engine-atomic/src/client/client.js#L8
// eslint-disable-next-line @fluentui/max-len
var KEYFRAMES_HYDRATOR = /@(-webkit-)?keyframes ([^{]+){((?:(?:from|to|(?:\d+\.?\d*%))\{(?:[^}])*})*)}/g;
var AT_RULES_HYDRATOR = /@(media|supports)[^{]+\{([\s\S]+?})\s*}/g;
var STYLES_HYDRATOR = /\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g;
var regexps = {
  k: KEYFRAMES_HYDRATOR,
  t: AT_RULES_HYDRATOR
};
/**
 * Should be called in a case of Server-Side rendering. Rehydrates cache from for a renderer to avoid double insertion
 * of classes to DOM.
 *
 * @public
 */

export function rehydrateRendererCache(renderer, target) {
  if (target === void 0) {
    target = typeof document === 'undefined' ? undefined : document;
  }

  if (target) {
    var styleElements = target.querySelectorAll('[data-make-styles-bucket]');
    styleElements.forEach(function (styleElement) {
      var bucketName = styleElement.dataset.makeStylesBucket;
      var regex = regexps[bucketName] || STYLES_HYDRATOR; // ðŸ‘‡ If some elements are not created yet, we will register them in renderer

      if (!renderer.styleElements[bucketName]) {
        renderer.styleElements[bucketName] = styleElement;
      }

      var match;

      while (match = regex.exec(styleElement.textContent)) {
        // "cacheKey" is either a class name or an animation name
        var cssRule = match[0];
        renderer.insertionCache[cssRule] = bucketName;
      }
    });
  }
}
//# sourceMappingURL=rehydrateRendererCache.js.map