import { DEFINITION_LOOKUP_TABLE } from '../constants';
import { hashSequence } from './utils/hashSequence';
/**
 * Reduces a classname map for slot to a classname string. Uses classnames according to text directions.
 *
 * @private
 */

export function reduceToClassName(classMap, dir) {
  var className = ''; // eslint-disable-next-line guard-for-in

  for (var propertyHash in classMap) {
    var classNameMapping = classMap[propertyHash];

    if (classNameMapping) {
      var hasRTLClassName = Array.isArray(classNameMapping);

      if (dir === 'rtl') {
        className += (hasRTLClassName ? classNameMapping[1] : classNameMapping) + ' ';
      } else {
        className += (hasRTLClassName ? classNameMapping[0] : classNameMapping) + ' ';
      }
    }
  }

  return className.slice(0, -1);
}
/**
 * Reduces classname maps for slots to classname strings. Registers them in a definition cache to be used by
 * `mergeClasses()`.
 *
 * @private
 */

export function reduceToClassNameForSlots(classesMapBySlot, dir) {
  var classNamesForSlots = {}; // eslint-disable-next-line guard-for-in

  for (var slotName in classesMapBySlot) {
    var classnamesForSlot = reduceToClassName(classesMapBySlot[slotName], dir);
    var sequenceHash = hashSequence(classnamesForSlot, dir);
    var resultSlotClasses = sequenceHash + ' ' + classnamesForSlot;
    DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];
    classNamesForSlots[slotName] = resultSlotClasses;
  }

  return classNamesForSlots;
}
//# sourceMappingURL=reduceToClassNameForSlots.js.map