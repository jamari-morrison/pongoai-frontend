"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSwitchState = void 0;

var React = /*#__PURE__*/require("react");

var react_utilities_1 = /*#__PURE__*/require("@fluentui/react-utilities");

var react_shared_contexts_1 = /*#__PURE__*/require("@fluentui/react-shared-contexts"); // TODO: This should be replaced with a useEvent hook
// eslint-disable-next-line @typescript-eslint/no-explicit-any


var on = function (element, eventName, callback) {
  element.addEventListener(eventName, callback);
  return function () {
    return element.removeEventListener(eventName, callback);
  };
};

var useSwitchState = function (state) {
  var _a = state.defaultChecked,
      defaultChecked = _a === void 0 ? false : _a,
      checked = state.checked,
      _b = state.disabled,
      disabled = _b === void 0 ? false : _b,
      onChange = state.onChange;
  var _c = state.root,
      onPointerDownCallback = _c.onPointerDown,
      onKeyDownCallback = _c.onKeyDown;
  var dir = react_shared_contexts_1.useFluent().dir;
  var inputRef = react_utilities_1.useMergedRefs(state.input.ref);
  var railRef = React.useRef(null);
  var internalState = React.useRef({
    internalValue: checked ? checked : defaultChecked,
    thumbIsDragging: false,
    disposables: []
  });

  var _d = react_utilities_1.useControllableState({
    defaultState: defaultChecked,
    state: checked,
    initialState: false
  }),
      currentValue = _d[0],
      setCurrentValue = _d[1];

  var _e = react_utilities_1.useBoolean(true),
      thumbAnimation = _e[0],
      _f = _e[1],
      showThumbAnimation = _f.setTrue,
      hideThumbAnimation = _f.setFalse;

  var _g = React.useState(currentValue === true ? 100 : 0),
      renderedPosition = _g[0],
      setRenderedPosition = _g[1];

  var setChecked = react_utilities_1.useEventCallback(function (ev, incomingValue) {
    ev.stopPropagation();
    ev.preventDefault();
    internalState.current.internalValue = incomingValue;
    onChange === null || onChange === void 0 ? void 0 : onChange(ev, {
      checked: incomingValue
    });
    setCurrentValue(incomingValue);
    setRenderedPosition(undefined);
  });
  var calculatePosition = React.useCallback(function (ev) {
    var _a;

    var currentBounds = (_a = railRef === null || railRef === void 0 ? void 0 : railRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();
    var railWidth = currentBounds.width;
    var railPosition = dir === 'rtl' ? currentBounds.right : currentBounds.left;
    var distance = dir === 'rtl' ? railPosition - ev.clientX : ev.clientX - railPosition;
    return react_utilities_1.clamp(distance / railWidth * 100, 0, 100);
  }, [dir]);
  var onPointerMove = React.useCallback(function (ev) {
    var incomingPosition = calculatePosition(ev);
    internalState.current.thumbIsDragging = true;
    hideThumbAnimation();
    setRenderedPosition(incomingPosition); // If the Switch reaches a new position of 0% or 100%, update the state and fire change.

    if (incomingPosition === 100 && internalState.current.internalValue !== true) {
      setChecked(ev, true);
    } else if (incomingPosition === 0 && internalState.current.internalValue !== false) {
      setChecked(ev, false);
    }
  }, [calculatePosition, hideThumbAnimation, setChecked]);
  var onPointerUp = React.useCallback(function (ev) {
    internalState.current.disposables.forEach(function (dispose) {
      return dispose();
    });
    internalState.current.disposables = [];
    inputRef.current.focus();

    if (internalState.current.thumbIsDragging) {
      var roundedPosition = Math.round(calculatePosition(ev) / 100) * 100;
      showThumbAnimation();

      if (roundedPosition === 100) {
        setChecked(ev, true);
      } else if (roundedPosition === 0) {
        setChecked(ev, false);
      }
    } else {
      setChecked(ev, !internalState.current.internalValue);
    }
  }, [calculatePosition, inputRef, setChecked, showThumbAnimation]);
  var onPointerDown = React.useCallback(function (ev) {
    var _a;

    var pointerId = ev.pointerId;
    var target = ev.target;
    onPointerDownCallback === null || onPointerDownCallback === void 0 ? void 0 : onPointerDownCallback(ev);
    showThumbAnimation();
    (_a = target.setPointerCapture) === null || _a === void 0 ? void 0 : _a.call(target, pointerId);
    internalState.current.thumbIsDragging = false;
    internalState.current.disposables.push(on(target, 'pointermove', onPointerMove), on(target, 'pointerup', onPointerUp), function () {
      var _a;

      (_a = target.releasePointerCapture) === null || _a === void 0 ? void 0 : _a.call(target, pointerId);
    });
  }, [onPointerDownCallback, onPointerMove, onPointerUp, showThumbAnimation]);
  var onKeyDown = React.useCallback(function (ev) {
    onKeyDownCallback === null || onKeyDownCallback === void 0 ? void 0 : onKeyDownCallback(ev);

    if (ev.key === ' ') {
      setChecked(ev, !internalState.current.internalValue);
    }
  }, [onKeyDownCallback, setChecked]);
  var currentPosition = renderedPosition !== undefined ? renderedPosition : currentValue ? 100 : 0;
  var rootStyles = {
    '--switch-checked-opacity': currentPosition / 100,
    '--switch-unchecked-opacity': (100 - currentPosition) / 100
  };
  var thumbWrapperStyles = {
    transform: "translate(" + (dir === 'rtl' ? -currentPosition : currentPosition) + "%)",
    transition: thumbAnimation ? 'transform .1s cubic-bezier(0.33, 0.0, 0.67, 1), opacity .1s cubic-bezier(0.33, 0.0, 0.67, 1)' : 'none'
  }; // Root Props

  state.root.style = rootStyles;

  if (!disabled) {
    state.root.onPointerDown = onPointerDown;
    state.root.onKeyDown = onKeyDown;
  } // Input Props


  state.input.checked = currentValue;
  state.input.disabled = disabled;
  state.input.ref = inputRef;
  state.input.readOnly = true;
  state.input.role = 'switch'; // Thumb Container Props

  state.thumbWrapper.style = thumbWrapperStyles; // Active Rail Props

  state.activeRail.ref = railRef;
  return state;
};

exports.useSwitchState = useSwitchState;
//# sourceMappingURL=useSwitchState.js.map