"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveStyleRules = void 0;

var tslib_1 = /*#__PURE__*/require("tslib");

var hash_1 = /*#__PURE__*/require("@emotion/hash");

var core_1 = /*#__PURE__*/require("rtl-css-js/core");

var constants_1 = /*#__PURE__*/require("../constants");

var compileCSS_1 = /*#__PURE__*/require("./compileCSS");

var compileKeyframeCSS_1 = /*#__PURE__*/require("./compileKeyframeCSS");

var expandShorthand_1 = /*#__PURE__*/require("./expandShorthand");

var generateCombinedMediaQuery_1 = /*#__PURE__*/require("./utils/generateCombinedMediaQuery");

var isMediaQuerySelector_1 = /*#__PURE__*/require("./utils/isMediaQuerySelector");

var isNestedSelector_1 = /*#__PURE__*/require("./utils/isNestedSelector");

var isSupportQuerySelector_1 = /*#__PURE__*/require("./utils/isSupportQuerySelector");

var normalizeNestedProperty_1 = /*#__PURE__*/require("./utils/normalizeNestedProperty");

var isObject_1 = /*#__PURE__*/require("./utils/isObject");

var getStyleBucketName_1 = /*#__PURE__*/require("./getStyleBucketName");

var hashClassName_1 = /*#__PURE__*/require("./utils/hashClassName");

var createCSSVariablesProxy_1 = /*#__PURE__*/require("./createCSSVariablesProxy");

var hashPropertyKey_1 = /*#__PURE__*/require("./utils/hashPropertyKey");

function pushToClassesMap(classesMap, propertyKey, ltrClassname, rtlClassname) {
  classesMap[propertyKey] = rtlClassname ? [ltrClassname, rtlClassname] : ltrClassname;
}

function pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS) {
  cssRulesByBucket[styleBucketName] = cssRulesByBucket[styleBucketName] || [];
  cssRulesByBucket[styleBucketName].push(ltrCSS);

  if (rtlCSS) {
    cssRulesByBucket[styleBucketName].push(rtlCSS);
  }
}

function resolveStyleRulesInner(styles, unstable_cssPriority, pseudo, media, support, cssClassesMap, cssRulesByBucket, rtlValue) {
  if (unstable_cssPriority === void 0) {
    unstable_cssPriority = 0;
  }

  if (pseudo === void 0) {
    pseudo = '';
  }

  if (media === void 0) {
    media = '';
  }

  if (support === void 0) {
    support = '';
  }

  if (cssClassesMap === void 0) {
    cssClassesMap = {};
  }

  if (cssRulesByBucket === void 0) {
    cssRulesByBucket = {};
  } // eslint-disable-next-line guard-for-in


  for (var property in styles) {
    var value = styles[property]; // eslint-disable-next-line eqeqeq

    if (value == null) {
      continue;
    }

    if (typeof value === 'string' || typeof value === 'number') {
      // uniq key based on a hash of property & selector, used for merging later
      var key = hashPropertyKey_1.hashPropertyKey(pseudo, media, support, property);
      var className = hashClassName_1.hashClassName({
        media: media,
        value: value.toString(),
        support: support,
        pseudo: pseudo,
        property: property,
        unstable_cssPriority: unstable_cssPriority
      });
      var rtlDefinition = rtlValue && {
        key: property,
        value: rtlValue
      } || core_1.convertProperty(property, value);
      var flippedInRtl = rtlDefinition.key !== property || rtlDefinition.value !== value;
      var rtlClassName = flippedInRtl ? hashClassName_1.hashClassName({
        value: rtlDefinition.value.toString(),
        property: rtlDefinition.key,
        pseudo: pseudo,
        media: media,
        support: support,
        unstable_cssPriority: unstable_cssPriority
      }) : undefined;
      var rtlCompileOptions = flippedInRtl ? {
        rtlClassName: rtlClassName,
        rtlProperty: rtlDefinition.key,
        rtlValue: rtlDefinition.value
      } : undefined;
      var styleBucketName = getStyleBucketName_1.getStyleBucketName(pseudo, media, support);

      var _a = compileCSS_1.compileCSS(tslib_1.__assign({
        className: className,
        media: media,
        pseudo: pseudo,
        property: property,
        support: support,
        value: value,
        unstable_cssPriority: unstable_cssPriority
      }, rtlCompileOptions)),
          ltrCSS = _a[0],
          rtlCSS = _a[1];

      pushToClassesMap(cssClassesMap, key, className, rtlClassName);
      pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS);
    } else if (property === 'animationName') {
      var animationNameValue = Array.isArray(value) ? value : [value];
      var animationNames = [];
      var rtlAnimationNames = [];

      for (var _i = 0, animationNameValue_1 = animationNameValue; _i < animationNameValue_1.length; _i++) {
        var keyframeObject = animationNameValue_1[_i];
        var keyframeCSS = compileKeyframeCSS_1.compileKeyframeRule(keyframeObject);
        var rtlKeyframeCSS = compileKeyframeCSS_1.compileKeyframeRule(core_1.convert(keyframeObject));
        var animationName = constants_1.HASH_PREFIX + hash_1.default(keyframeCSS);
        var rtlAnimationName = void 0;
        var keyframeRules = compileKeyframeCSS_1.compileKeyframesCSS(animationName, keyframeCSS);
        var rtlKeyframeRules = [];

        if (keyframeCSS === rtlKeyframeCSS) {
          // If CSS for LTR & RTL are same we will re-use animationName from LTR to avoid duplication of rules in output
          rtlAnimationName = animationName;
        } else {
          rtlAnimationName = constants_1.HASH_PREFIX + hash_1.default(rtlKeyframeCSS);
          rtlKeyframeRules = compileKeyframeCSS_1.compileKeyframesCSS(rtlAnimationName, rtlKeyframeCSS);
        }

        for (var i = 0; i < keyframeRules.length; i++) {
          pushToCSSRules(cssRulesByBucket, // keyframes styles should be inserted into own bucket
          'k', keyframeRules[i], rtlKeyframeRules[i]);
        }

        animationNames.push(animationName);
        rtlAnimationNames.push(rtlAnimationName);
      }

      resolveStyleRulesInner({
        animationName: animationNames.join(', ')
      }, unstable_cssPriority, pseudo, media, support, cssClassesMap, cssRulesByBucket, rtlAnimationNames.join(', '));
    } else if (isObject_1.isObject(value)) {
      if (isNestedSelector_1.isNestedSelector(property)) {
        resolveStyleRulesInner(value, unstable_cssPriority, pseudo + normalizeNestedProperty_1.normalizeNestedProperty(property), media, support, cssClassesMap, cssRulesByBucket);
      } else if (isMediaQuerySelector_1.isMediaQuerySelector(property)) {
        var combinedMediaQuery = generateCombinedMediaQuery_1.generateCombinedQuery(media, property.slice(6).trim());
        resolveStyleRulesInner(value, unstable_cssPriority, pseudo, combinedMediaQuery, support, cssClassesMap, cssRulesByBucket);
      } else if (isSupportQuerySelector_1.isSupportQuerySelector(property)) {
        var combinedSupportQuery = generateCombinedMediaQuery_1.generateCombinedQuery(support, property.slice(9).trim());
        resolveStyleRulesInner(value, unstable_cssPriority, pseudo, media, combinedSupportQuery, cssClassesMap, cssRulesByBucket);
      }
    }
  }

  return [cssClassesMap, cssRulesByBucket];
}
/**
 * Transforms input styles to classes maps & CSS rules.
 *
 * @internal
 */


function resolveStyleRules(styles, unstable_cssPriority) {
  if (unstable_cssPriority === void 0) {
    unstable_cssPriority = 0;
  } // expandShorthand() and resolveProxyValues() are recursive functions and should be evaluated once for a style object


  var expandedStyles = expandShorthand_1.expandShorthand(createCSSVariablesProxy_1.resolveProxyValues(styles));
  return resolveStyleRulesInner(expandedStyles, unstable_cssPriority);
}

exports.resolveStyleRules = resolveStyleRules;
//# sourceMappingURL=resolveStyleRules.js.map