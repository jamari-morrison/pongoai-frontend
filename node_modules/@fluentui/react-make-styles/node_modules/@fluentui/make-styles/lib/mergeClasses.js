import { DEFINITION_LOOKUP_TABLE, LOOKUP_DEFINITIONS_INDEX, LOOKUP_DIR_INDEX, SEQUENCE_HASH_LENGTH, SEQUENCE_PREFIX } from './constants';
import { hashSequence } from './runtime/utils/hashSequence';
import { reduceToClassName } from './runtime/reduceToClassNameForSlots'; // Contains a mapping of previously resolved sequences of atomic classnames

var mergeClassesCachedResults = {};
var SEQUENCE_SIZE = SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH;
export function mergeClasses() {
  // arguments are parsed manually to avoid double loops as TS & Babel transforms rest via an additional loop
  // @see https://babeljs.io/docs/en/babel-plugin-transform-parameters
  var dir = null;
  var resultClassName = ''; // Is used as a cache key to avoid object merging

  var sequenceMatch = '';
  var sequenceMappings = [];

  for (var i = 0; i < arguments.length; i++) {
    // eslint-disable-next-line prefer-rest-params
    var className = arguments[i];

    if (typeof className === 'string') {
      // All classes generated by `makeStyles()` are prefixed by a sequence hash, this allows to identify class sets
      // without parsing each className in a string
      var sequenceIndex = className.indexOf(SEQUENCE_PREFIX);

      if (sequenceIndex === -1) {
        resultClassName += className + ' ';
      } else {
        var sequenceId = className.slice(sequenceIndex, sequenceIndex + SEQUENCE_SIZE);
        var sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId]; // Handles a case with mixed classnames, i.e. "ui-button ATOMIC_CLASSES"

        if (sequenceIndex > 0) {
          resultClassName += className.slice(0, sequenceIndex);
        }

        if (sequenceMapping) {
          sequenceMatch += sequenceId;
          sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);

          if (process.env.NODE_ENV !== 'production') {
            if (dir !== null && dir !== sequenceMapping[LOOKUP_DIR_INDEX]) {
              // eslint-disable-next-line no-console
              console.error("mergeClasses(): a passed string contains an identifier (" + sequenceId + ") that has different direction " + ("(dir=\"" + (sequenceMapping[1] ? 'rtl' : 'ltr') + "\") setting than other classes. This is not supported. ") + ("Source string: " + className));
            }
          }

          dir = sequenceMapping[LOOKUP_DIR_INDEX];
        } else {
          if (process.env.NODE_ENV !== 'production') {
            // eslint-disable-next-line no-console
            console.error("mergeClasses(): a passed string contains an identifier (" + sequenceId + ") that does not match any entry " + ("in cache. Source string: " + className));
          }
        }
      }

      if (process.env.NODE_ENV !== 'production') {
        if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) {
          // eslint-disable-next-line no-console
          console.error('mergeClasses(): a passed string contains multiple identifiers of atomic classes (classes that start ' + ("with \"" + SEQUENCE_PREFIX + "\"), it's possible that passed classes were concatenated in a wrong way. ") + ("Source string: " + className));
        }
      }
    }
  } // .slice() there allows to avoid trailing space for non-atomic classes
  // "ui-button ui-flex " => "ui-button ui-flex"


  if (sequenceMatch === '') {
    return resultClassName.slice(0, -1);
  } // It's safe to reuse results to avoid continuous merging as results are stable
  // "__seq1 ... __seq2 ..." => "__seq12 ..."


  var mergeClassesResult = mergeClassesCachedResults[sequenceMatch];

  if (mergeClassesResult !== undefined) {
    return resultClassName + mergeClassesResult;
  } // eslint-disable-next-line prefer-spread


  var resultDefinitions = Object.assign.apply(Object, // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later
  [{}].concat(sequenceMappings));
  var atomicClassNames = reduceToClassName(resultDefinitions, dir); // Each merge of classes generates a new sequence of atomic classes that needs to be registered

  var newSequenceHash = hashSequence(atomicClassNames, dir);
  atomicClassNames = newSequenceHash + ' ' + atomicClassNames;
  mergeClassesCachedResults[sequenceMatch] = atomicClassNames;
  DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultDefinitions, dir];
  return resultClassName + atomicClassNames;
}
//# sourceMappingURL=mergeClasses.js.map