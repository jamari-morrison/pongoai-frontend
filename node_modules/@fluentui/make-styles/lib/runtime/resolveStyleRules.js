import { __assign } from "tslib";
import hashString from '@emotion/hash';
import { convert, convertProperty } from 'rtl-css-js/core';
import { HASH_PREFIX } from '../constants';
import { compileCSS } from './compileCSS';
import { compileKeyframeRule, compileKeyframesCSS } from './compileKeyframeCSS';
import { expandShorthand } from './expandShorthand';
import { generateCombinedQuery } from './utils/generateCombinedMediaQuery';
import { isMediaQuerySelector } from './utils/isMediaQuerySelector';
import { isNestedSelector } from './utils/isNestedSelector';
import { isSupportQuerySelector } from './utils/isSupportQuerySelector';
import { normalizeNestedProperty } from './utils/normalizeNestedProperty';
import { isObject } from './utils/isObject';
import { getStyleBucketName } from './getStyleBucketName';
import { hashClassName } from './utils/hashClassName';
import { resolveProxyValues } from './createCSSVariablesProxy';
import { hashPropertyKey } from './utils/hashPropertyKey';

function pushToClassesMap(classesMap, propertyKey, ltrClassname, rtlClassname) {
  classesMap[propertyKey] = rtlClassname ? [ltrClassname, rtlClassname] : ltrClassname;
}

function pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS) {
  cssRulesByBucket[styleBucketName] = cssRulesByBucket[styleBucketName] || [];
  cssRulesByBucket[styleBucketName].push(ltrCSS);

  if (rtlCSS) {
    cssRulesByBucket[styleBucketName].push(rtlCSS);
  }
}

function resolveStyleRulesInner(styles, unstable_cssPriority, pseudo, media, support, cssClassesMap, cssRulesByBucket, rtlValue) {
  if (unstable_cssPriority === void 0) {
    unstable_cssPriority = 0;
  }

  if (pseudo === void 0) {
    pseudo = '';
  }

  if (media === void 0) {
    media = '';
  }

  if (support === void 0) {
    support = '';
  }

  if (cssClassesMap === void 0) {
    cssClassesMap = {};
  }

  if (cssRulesByBucket === void 0) {
    cssRulesByBucket = {};
  } // eslint-disable-next-line guard-for-in


  for (var property in styles) {
    var value = styles[property]; // eslint-disable-next-line eqeqeq

    if (value == null) {
      continue;
    }

    if (typeof value === 'string' || typeof value === 'number') {
      // uniq key based on a hash of property & selector, used for merging later
      var key = hashPropertyKey(pseudo, media, support, property);
      var className = hashClassName({
        media: media,
        value: value.toString(),
        support: support,
        pseudo: pseudo,
        property: property,
        unstable_cssPriority: unstable_cssPriority
      });
      var rtlDefinition = rtlValue && {
        key: property,
        value: rtlValue
      } || convertProperty(property, value);
      var flippedInRtl = rtlDefinition.key !== property || rtlDefinition.value !== value;
      var rtlClassName = flippedInRtl ? hashClassName({
        value: rtlDefinition.value.toString(),
        property: rtlDefinition.key,
        pseudo: pseudo,
        media: media,
        support: support,
        unstable_cssPriority: unstable_cssPriority
      }) : undefined;
      var rtlCompileOptions = flippedInRtl ? {
        rtlClassName: rtlClassName,
        rtlProperty: rtlDefinition.key,
        rtlValue: rtlDefinition.value
      } : undefined;
      var styleBucketName = getStyleBucketName(pseudo, media, support);

      var _a = compileCSS(__assign({
        className: className,
        media: media,
        pseudo: pseudo,
        property: property,
        support: support,
        value: value,
        unstable_cssPriority: unstable_cssPriority
      }, rtlCompileOptions)),
          ltrCSS = _a[0],
          rtlCSS = _a[1];

      pushToClassesMap(cssClassesMap, key, className, rtlClassName);
      pushToCSSRules(cssRulesByBucket, styleBucketName, ltrCSS, rtlCSS);
    } else if (property === 'animationName') {
      var animationNames = Array.isArray(value) ? value : [value];
      var keyframeCSS = '';
      var keyframeRtlCSS = '';
      var names = [];
      var namesRtl = [];

      for (var _i = 0, animationNames_1 = animationNames; _i < animationNames_1.length; _i++) {
        var val = animationNames_1[_i];
        var keyframe = compileKeyframeRule(val);
        var name_1 = HASH_PREFIX + hashString(keyframe);
        keyframeCSS += compileKeyframesCSS(name_1, keyframe);
        names.push(name_1);
        var rtlKeyframe = compileKeyframeRule(convert(val));

        if (keyframe !== rtlKeyframe) {
          var nameRtl = HASH_PREFIX + hashString(rtlKeyframe);
          keyframeRtlCSS += compileKeyframesCSS(nameRtl, rtlKeyframe);
          namesRtl.push(nameRtl);
        } else {
          namesRtl.push(name_1);
        }
      }

      var animationName = names.join(' ');
      var animationNameRtl = namesRtl.join(' ');
      pushToCSSRules(cssRulesByBucket, 'k', // keyframes styles should be inserted into own bucket
      keyframeCSS, keyframeRtlCSS || undefined);
      resolveStyleRulesInner({
        animationName: animationName
      }, unstable_cssPriority, pseudo, media, support, cssClassesMap, cssRulesByBucket, animationNameRtl);
    } else if (isObject(value)) {
      if (isNestedSelector(property)) {
        resolveStyleRulesInner(value, unstable_cssPriority, pseudo + normalizeNestedProperty(property), media, support, cssClassesMap, cssRulesByBucket);
      } else if (isMediaQuerySelector(property)) {
        var combinedMediaQuery = generateCombinedQuery(media, property.slice(6).trim());
        resolveStyleRulesInner(value, unstable_cssPriority, pseudo, combinedMediaQuery, support, cssClassesMap, cssRulesByBucket);
      } else if (isSupportQuerySelector(property)) {
        var combinedSupportQuery = generateCombinedQuery(support, property.slice(9).trim());
        resolveStyleRulesInner(value, unstable_cssPriority, pseudo, media, combinedSupportQuery, cssClassesMap, cssRulesByBucket);
      }
    }
  }

  return [cssClassesMap, cssRulesByBucket];
}
/**
 * Transforms input styles to classes maps & CSS rules.
 *
 * @internal
 */


export function resolveStyleRules(styles, unstable_cssPriority) {
  if (unstable_cssPriority === void 0) {
    unstable_cssPriority = 0;
  } // expandShorthand() and resolveProxyValues() are recursive functions and should be evaluated once for a style object


  var expandedStyles = expandShorthand(resolveProxyValues(styles));
  return resolveStyleRulesInner(expandedStyles, unstable_cssPriority);
}
//# sourceMappingURL=resolveStyleRules.js.map