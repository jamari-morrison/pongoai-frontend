import { reduceToClassNameForSlots } from './runtime/reduceToClassNameForSlots';
import { resolveStyleRulesForSlots } from './resolveStyleRulesForSlots';
export function makeStyles(stylesBySlots, unstable_cssPriority) {
  if (unstable_cssPriority === void 0) {
    unstable_cssPriority = 0;
  }

  var insertionCache = {};
  var classesMapBySlot = null;
  var cssRules = null;
  var ltrClassNamesForSlots = null;
  var rtlClassNamesForSlots = null;

  function computeClasses(options) {
    var _a;

    var dir = options.dir,
        renderer = options.renderer;

    if (classesMapBySlot === null) {
      _a = resolveStyleRulesForSlots(stylesBySlots, unstable_cssPriority), classesMapBySlot = _a[0], cssRules = _a[1];
    }

    var isLTR = dir === 'ltr'; // As RTL classes are different they should have a different cache key for insertion

    var rendererId = isLTR ? renderer.id : renderer.id + 'r';

    if (isLTR) {
      if (ltrClassNamesForSlots === null) {
        ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
      }
    } else {
      if (rtlClassNamesForSlots === null) {
        rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);
      }
    }

    if (insertionCache[rendererId] === undefined) {
      renderer.insertCSSRules(cssRules);
      insertionCache[rendererId] = true;
    }

    return isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;
  }

  return computeClasses;
}
//# sourceMappingURL=makeStyles.js.map