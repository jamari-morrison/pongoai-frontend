"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reduceToClassNameForSlots = exports.reduceToClassName = void 0;

var constants_1 = /*#__PURE__*/require("../constants");

var hashSequence_1 = /*#__PURE__*/require("./utils/hashSequence");
/**
 * Reduces a classname map for slot to a classname string. Uses classnames according to text directions.
 *
 * @private
 */


function reduceToClassName(classMap, dir) {
  var className = ''; // eslint-disable-next-line guard-for-in

  for (var propertyHash in classMap) {
    var classNameMapping = classMap[propertyHash];

    if (classNameMapping) {
      var hasRTLClassName = Array.isArray(classNameMapping);

      if (dir === 'rtl') {
        className += (hasRTLClassName ? classNameMapping[1] : classNameMapping) + ' ';
      } else {
        className += (hasRTLClassName ? classNameMapping[0] : classNameMapping) + ' ';
      }
    }
  }

  return className.slice(0, -1);
}

exports.reduceToClassName = reduceToClassName;
/**
 * Reduces classname maps for slots to classname strings. Registers them in a definition cache to be used by
 * `mergeClasses()`.
 *
 * @private
 */

function reduceToClassNameForSlots(classesMapBySlot, dir) {
  var classNamesForSlots = {}; // eslint-disable-next-line guard-for-in

  for (var slotName in classesMapBySlot) {
    var classnamesForSlot = reduceToClassName(classesMapBySlot[slotName], dir);
    var sequenceHash = hashSequence_1.hashSequence(classnamesForSlot, dir);
    var resultSlotClasses = sequenceHash + ' ' + classnamesForSlot;
    constants_1.DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];
    classNamesForSlots[slotName] = resultSlotClasses;
  }

  return classNamesForSlots;
}

exports.reduceToClassNameForSlots = reduceToClassNameForSlots;
//# sourceMappingURL=reduceToClassNameForSlots.js.map