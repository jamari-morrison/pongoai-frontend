import * as React from 'react';
import { useConst } from './useConst';

function isUndefined(state) {
  return typeof state === 'undefined';
}

function isFactoryDispatch(newState) {
  return typeof newState === 'function';
}
/**
 * A useState 'like' hook that allows optional user control
 * Useful for components which allow uncontrolled and controlled behaviour for users
 * @returns - https://reactjs.org/docs/hooks-state.html
 */


export var useControllableState = function (options) {
  var isControlled = useIsControlled(options.state);
  var initialState = isUndefined(options.defaultState) ? options.initialState : options.defaultState;

  var _a = React.useState(initialState),
      internalState = _a[0],
      setInternalState = _a[1];

  var state = isControlled ? options.state : internalState;
  var stateRef = React.useRef(state);
  React.useEffect(function () {
    stateRef.current = state;
  }, [state]); // To match the behavior of the setter returned by React.useState, this callback's identity
  // should never change. This means it MUST NOT directly reference variables that can change.

  var setState = React.useCallback(function (newState) {
    // React dispatch can use a factory
    // https://reactjs.org/docs/hooks-reference.html#functional-updates
    if (isFactoryDispatch(newState)) {
      stateRef.current = newState(stateRef.current);
    } else {
      stateRef.current = newState;
    }

    setInternalState(stateRef.current);
  }, []);
  return [state, setState];
};
/**
 * Helper hook to handle previous comparison of controlled/uncontrolled
 * Prints an error when isControlled value switches between subsequent renders
 * @returns - whether the value is controlled
 */

var useIsControlled = function (controlledValue) {
  var isControlled = useConst(controlledValue !== undefined);

  if (process.env.NODE_ENV !== 'production') {
    // We don't want these warnings in production even though it is against native behaviour
    // eslint-disable-next-line react-hooks/rules-of-hooks
    React.useEffect(function () {
      if (isControlled !== (controlledValue !== undefined)) {
        var error = new Error();
        var controlWarning = isControlled ? 'a controlled value to be uncontrolled' : 'an uncontrolled value to be controlled';
        var undefinedWarning = isControlled ? 'defined to an undefined' : 'undefined to a defined'; // eslint-disable-next-line no-console

        console.error([// Default react error
        'A component is changing ' + controlWarning + '. This is likely caused by the value', 'changing from ' + undefinedWarning + ' value, which should not happen.', 'Decide between using a controlled or uncontrolled input element for the lifetime of the component.', 'More info: https://reactjs.org/link/controlled-components', error.stack].join(' '));
      }
    }, [isControlled, controlledValue]);
  }

  return isControlled;
};
//# sourceMappingURL=useControllableState.js.map